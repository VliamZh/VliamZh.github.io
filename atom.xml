<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>vliamzh</title>
  
  
  <link href="https://vliamzh.github.io/atom.xml" rel="self"/>
  
  <link href="https://vliamzh.github.io/"/>
  <updated>2024-08-04T09:03:50.305Z</updated>
  <id>https://vliamzh.github.io/</id>
  
  <author>
    <name>vliamzh</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>UP收集</title>
    <link href="https://vliamzh.github.io/2024/08/04/UP%E6%94%B6%E9%9B%86/"/>
    <id>https://vliamzh.github.io/2024/08/04/UP%E6%94%B6%E9%9B%86/</id>
    <published>2024-08-04T09:01:41.000Z</published>
    <updated>2024-08-04T09:03:50.305Z</updated>
    
    <content type="html"><![CDATA[<ol><li><p><a href="https://space.bilibili.com/2055684362">龚大的杂货铺</a></p><p>【上帝视角看GPU（1）：图形流水线基础】 <a href="https://www.bilibili.com/video/BV1P44y1V7bu/?share_source=copy_web&vd_source=6177a28327498e5a102082524afdc378">https://www.bilibili.com/video/BV1P44y1V7bu/?share_source=copy_web&amp;vd_source=6177a28327498e5a102082524afdc378</a></p></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;ol&gt;
&lt;li&gt;&lt;p&gt;&lt;a href=&quot;https://space.bilibili.com/2055684362&quot;&gt;龚大的杂货铺&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;【上帝视角看GPU（1）：图形流水线基础】 &lt;a href=&quot;https://www.bilibili.com/video/</summary>
      
    
    
    
    <category term="其它" scheme="https://vliamzh.github.io/categories/%E5%85%B6%E5%AE%83/"/>
    
    <category term="up" scheme="https://vliamzh.github.io/categories/%E5%85%B6%E5%AE%83/up/"/>
    
    
    <category term="up" scheme="https://vliamzh.github.io/tags/up/"/>
    
    <category term="bilibili" scheme="https://vliamzh.github.io/tags/bilibili/"/>
    
  </entry>
  
  <entry>
    <title>UVM复习</title>
    <link href="https://vliamzh.github.io/2024/08/04/UVM%E5%A4%8D%E4%B9%A0/"/>
    <id>https://vliamzh.github.io/2024/08/04/UVM%E5%A4%8D%E4%B9%A0/</id>
    <published>2024-08-04T08:46:41.000Z</published>
    <updated>2024-08-04T08:47:51.214Z</updated>
    
    <content type="html"><![CDATA[<h1 id="UVM白皮书复习"><a href="#UVM白皮书复习" class="headerlink" title="UVM白皮书复习"></a>UVM白皮书复习</h1><h1 id="第二章"><a href="#第二章" class="headerlink" title="第二章"></a>第二章</h1><h2 id="常用"><a href="#常用" class="headerlink" title="常用"></a>常用</h2><ol><li>UVM是个库，所有东西用类实现Class，类有函数和任务，还有成员变量</li><li>drv所做的事在main phase完成，需要vif【env中config db传递】，负责把tr级别信息转变为DUT端口级别信息；</li><li>uvm_info打印宏，路径索引+输出，参数123【打印信息的归类别】【打印信息的具体内容】【冗余级别】，uvm_fatal类似，但是它表示出现了重大问题无法继续下去，<strong>不需要冗余级别</strong>，会在第二个信息打印出来后停止仿真；</li><li>类的实例化new，只定义不实例化的类没有意义，实例化会在内存分配空间，并把该空间的指针返回，利用指针可以查看类的各个成员变量和调用类的函数任务等</li><li>include uvm_macros.svh，包含了众多的UVM宏定义</li><li>import uvm_pkg::<em>，这样*<em>编译的时候才会认识uvm_driver等类名</em></em></li></ol><p>import不会复制文本内容。但是import可package中内容引入import语句所在的作用域，以帮助编译器能够识别被引用的类，并共享数据</p><p><code>include将文件中所有文本原样插入包含的文件中。这是一个预处理语句，</code>include在import之前执行。他的主要作用就是在package中平铺其他文件，从而在编译时能够将多个文件中定义的类置于这个包中，形成一种逻辑上的包含关系。</p><ol><li>factory 机制：<strong>集成在一个宏内，uvm_component_utils，作用广泛，其中一个是把drv注册到表中</strong></li><li>run_test创造一个drv实例，并自动调用main phase，根据类名创建了一个实例并自动调用main phase——factory机制</li><li>objection机制——finish语句，控制验证平台的关闭，每个phase都会检查是否有objection被提起，没有立马结束仿真，有的话要等objection撤销再结束，raise objection必须在main phase中第一个消耗仿真时间的语句之前出现<ol><li>仿真时间，$time函数打印的时间</li><li>运行时间，一个测试用例的运行时间CPU时间</li></ol></li><li>virtual interface，避免了绝对路径，提高了验证平台的可移植性和可重用性，之所以要用virtual，因为只有module可以用interface，类中必须要加virtual；</li><li>run test建立了新的层次结构，脱离了top tb，必须用config db机制传递参数和引用变量</li><li>config db机制分为set和get，寄信和收信，四个参数，set参数目标的路径索引【前两个参数组成】，<strong>成员变量</strong>，传递的数据；第三个成员变量set和get要保一致；</li><li>build phase在uvm启动后自动执行，在new函数后main phase前，在这里实例化成员变量与config db的set和get操作传递一些数据，且要super.build_phase，是函数phase，不消耗仿真时间，但是main phase是任务phase</li><li>transaction，<strong>uvm组件间的信息传递都是基于tr级别的</strong>，tr代表了一个协议内的一种数据包，内部定义各种参数，不同的平台有不同的tr，继承与uvm_sequence_item【方便使用sequence机制】，用uvm_object_utils注册，与component不同，tr有生命周期，在仿真的某一时间段存在；</li><li>pre_randmosize,randmosize,post_randomize，assert(xx.randmosize)会自动在之前之后调用pre和post函数；</li><li>env容器类，run_test只能实例化一个，<strong>在env完成相关组件定义后的实例化</strong>，run_test传递的参数是更高级的类；实例化用drv::type_id::create(“drv”,this)【只有factory注册的类才能用，方便使用重载功能，this表示父节点是env，run_test创建的实例树根名字是uvm_test_top】</li><li>build phase<strong>执行顺序自上而下</strong></li><li>monitor，监测DUT的行为，需要vif【env中config db传递】，监测DUT<strong>输入输出</strong>信号变化后判定DUT的行为是否正确，monitor负责收集DUT的端口级别信息，并转变为tr级别传给ref或者scb处理；env中实例化两个mon的必要性：<strong>由于drv产生并输出tr到DUT端口，所以drv可以直接将tr信号传给ref或scb，但是在drv侧设置mon可以减少出错的概率，drv和mon可能是不同人员编写的，对协议的理解可能不同，所以不仅方便代码重用还可以减少出错；</strong></li><li>agent，drv和mon代码高度相似，<strong>因为二者处理的是同一种协议，在一种规则下做不同的事罢了，所以通过agt将二者封装在一起</strong>，不同的agt代表不同的协议，【可重用性】，内部可以根据is_active实现是否实例化drv和sqr；<strong>因为往往输出侧只需要mon监测，不需要drv和sqr</strong></li><li>将组件的实例化交到main phase会出错，不仅可以在build phase实例化，也可以在new函数实例化，但是new函数实例化将无法通过直接赋值的方式传递is_active的值【在build phase也一样】，所以在组件实例化之前要用config db传递好is active</li><li>reference model，完成与DUT相同的功能，其输出传给scb用于与DUT的输出比较，这里主要是TLM通信，<strong>怎么从i_agt获取tr并传给scb</strong></li><li>TLM实现component组件间的tr级别通信，发送：uvm_analysis_port【参数化类，参数是tr】ap，ap需要在build phase通过new实例化，然后在main phase中ap.write往ap内写入tr；接收：uvm_blocking_get_port【参数化类，参数是tr】，与ap类似也要实例化，在main phase通过port.get获取tr；实现通信：需要定义uvm_tlm_analysis_fifo，【参数化类，参数是存储在内部的tr】在env中定义fifo并在build phase实例化，然在connect phase中连接mon的analysisi port和ref中的blocking get port，【i_agt.ap.conect(agt_mdl_fifo.<strong>analysis_export</strong>),mdl.port.connect(agt_mdl_fifo.<strong>blocking_get_export</strong>)】;需要fifo的原因：因为analysis_port是非阻塞的，ap.write调用马上返回不等待数据的被接收，如果正在write的同时blocking get port忙于其他事情，没有准备好接收新数据，这就需要fifo来暂存</li><li>connect phase，在build phase后执行，<strong>执行顺序自下而上，能够保证指针非空</strong></li><li>scoreboard，main phase利用fork join执行两个进程，一个获取DUT输出数据【有延时】，一个获取来自于mon或者ref的数据【放入队列里，ref处理的数据是无延时，保证比DUT先到，DUT随后从队列里弹出数据进行比较即可】</li><li>field automation机制，在tr中使用，利用uvm_object_utils_begin…..uvm_object_utils_end注册所有字段，field系列宏和字段类型有关，经过注册后，可以直接使用copy compare print等函数，无需自己定义，提高了效率，简化drv和mon；</li><li>sequencer，sequence机制用于产生激励，sequencer定义非常简单【事实上无需怎么定义】【参数化类，表明产生的tr类型】，sequencer产生tr，drv驱动tr【所以drv也要参数化类，参数是tr类型，方便直接使用预先定义好的成员变量req】，要在env中实例化sqr</li><li>sequence机制，sequence不属于验证平台任一部分，sqr帮助sequence产生的tr最终能送给drv，sqr只有在seq存在时才有价值【seq是弹夹，sqr是枪，tr是子弹】，<strong>sequence是object，和tr一样具有生命周期！</strong>sequence定义【参数化类，参数是tr】，内部有body任务，sequence启动后会自动执行pre_body body post_body，一般来说body内都会uvm_do(tr)，uvm_do会干三件事：创建tr实例，随机化tr，将tr送给sqr；【用start_item+随机化+finish_item自定义也行】</li><li>sequence向sqr发送tr前会发送请求，sqr会把此请求放入仲裁队列中，sqr只做两件事：1. 检测仲裁队列是否有来自seq的发送tr请求；2. 检测drv是否有申请tr的请求；<ol><li>仲裁队列有请求，drv没请求，sqr会等drv直到drv申请新的tr请求，sqr允许seq的发送请求，seq开始向sqr发送tr，sqr把tr交给drv</li><li>仲裁队列没请求，drv有请求，sqr会等seq直到seq递交新的发送tr请求，sqr马上同意，seq给sqr发送tr，sqr把tr交给drv</li><li>仲裁队列有请求，drv有请求，sqr同意seq的发送请求，seq给sqr发tr，sqr把tr交给drv</li></ol></li></ol><p>drv申请tr的方法：drv内建成员变量seq_item_port，sqr内建成员变量seq_item_export，二者建立起了通道，通道类型是drv和sqr定义时指定的参数tr，所以在agt内的connect phase用drv.seq_item_port.connect(sqr.seq_item_export)连接好，接着drv用get_next_item【try_next_item是非阻塞的，会询问sqr是否有tr，有的话得到，没有的话直接返回】向sqr申请tr，然后while一直驱动tr，最后用seq_item_port.done()结束【告诉sqr我drv已经拿到了tr，它可以把存在它那的tr副本给删除了——一种握手机制增加可靠性】</p><p>seq发送tr的方法：uvm_do宏，开始：产生一个tr交给sqr，sqr把tr交给drv，drv拿到了tr后，发出item_done信号，uvm_do宏执行完毕；开始执行下一个tr；</p><p>seq定义好如何启动：1. 在某个component的main_phase启动seq即可，【先要创建seq的实例】利用sequence.start(xxx.sqr);要指明哪个sqr指针即将seq产生的tr交给哪个sqr；2. 在sqr中的main phase启动seq【提起和撤销objection也可以在这】；3. 用default_sequence，在某个component的build phase中通过config db的方式，存在很多phase，所以要制定是main phase还是configure phase还是reset phase等从而使得sqr知道在哪个phase启动这个seq；可以在uvm_test_top中写也可以在top_tb中的intial begin内写或者agt的build phase写都是可以的；使用default_sequence后，如何提起和撤销objection：在uvm_sequence基类中有starting_phase变量【类型是uvm_phase】，sqr启动default_sequence后会自动在sqr中做seq.starting_phase&#x3D;phase；seq.start(this)；所以可以在seq中用if(starting_phase≠null)的时候，starting_phase.raise_objection(this)，#若干时间后，if(starting_Phase≠null)，starting_phase.drop_objection(this)。这样关联起了objection和sequence，其他地方无需再设置objection！</p><pre><code class="verilog">uvm_config_db#(uvm_object_wrapper)::set(this,                                                                        ”i_agt.sqr.main_phase”,                                                                        ”default_sequence”,                                                                        my_sequence::type_id::get())</code></pre><p>objection机制：一般伴随sequence，在seq出现的地方才提起和撤销【所以在main phase里面提起和撤销objection，这样各个组件的main phase会执行完毕】【所以上面的sqr中的main phase启动seq，也可以在这里提起撤销objection】，即seq是弹夹，弹夹里面的子弹用光了可以结束仿真了；</p><ol><li>base_test，<strong>真正的测试用例是base_test派生的类</strong>，在build phase内<strong>实例化env</strong>，并且<strong>设置sequencer的default_sequence【其他地方就不需要再设置了】</strong>，另外可以自定义加入report_phase，设置超时退出时间，利用config db设置某些参数的值；此时run_test（base_test），uvm_test_top是base_test的实例了；</li><li>测试用例数量一直增加，但是后面的测试用例不能影响到已经建好的，前面通过default_sequence启动seq1，如何才能不影响seq1的前提下启动seq2呢，1. <strong>一个test对应一个seq</strong>，然后在seq的body中提起和撤销objection，中间发送tr；2. 在对应的test内部启动default_sequence设置是seq1的实例；3. 在命令行用UVM_TESTNAME&#x3D;XX，决定启动哪一个test测试用例，即启动了对应的seq！</li><li>测试用例的启动过程：<ol><li>module top_tb</li><li>run_test</li><li>启动验证平台</li><li>根据UVM_TESTNAME产生casen的实例</li><li>执行build phase<strong>自上而下形成完整的树结构</strong></li><li>执行各个节点的connect phase main phase</li><li>所有phase执行完毕，结束仿真；</li></ol></li></ol><h1 id="第三章-UVM基础"><a href="#第三章-UVM基础" class="headerlink" title="第三章 UVM基础"></a>第三章 UVM基础</h1><ol><li><p>继承于uvm_component和uvm_object的相关类与用途【<strong>com拥有树形结构和phase自动执行等特点</strong>】</p><ol><li>uvm_sequence_item：封装了一定信息的类【tr是它的子类】，drv会从sqr得到tr，并转为端口级别信号，mon从DUT的pin上获取信息并转换成tr级别发给scb比较；</li><li>uvm_sequence：是sequence_item的组合，sequence向sqr发送tr，sqr把tr交给drv</li><li>uvm_sequencer：组织管理sequence，drv要求tr时把sequence生成的tr转发给drv</li><li>uvm_agent：把drv和mon封装在一起，从可重新角度考虑!</li><li>uvm_env：将验证平台固定不变的component封装在一起，不同的测试用例例化env即可；</li><li>uvm_test：派生测试用例，任何一个测试用例都要实例化env</li><li>config，uvm_object派生，规范行为，配置参数通过config db设置给需要这些参数component</li><li>uvm_phase，控制uvm_component的行为方式，使得component平滑在各个phase之间运转</li></ol></li><li><p>uvm_object和uvm_component相关宏</p><ol><li>注册：uvm_object_utils uvm_component_utils</li><li>域的自动化相关：uvm_object_utils_begin(tr) …. uvm_object_utils_end，对于component来说，比如drv内有个num变量用了此机制，并在build phase调用super.build_phase，那么可以省略build phase中的config db get语句，省略get！</li></ol></li><li><p>object和component区别</p><p>component不能用object中的clone函数，因为component作为UVM树节点存在会失去该方面的特征，因为clone出来的类其父辈无法指定，clone&#x3D;new+copy</p></li><li><p><strong>UVM树的根</strong>是<strong>uvm_root类</strong>【保证了验证平台的树根只有一个】，实例化名是uvm_top【唯一实例，是uvm_comp类型】，子类是<strong>casen即测试用例</strong>，<strong>对应实例化名是uvm_test_top</strong>，<strong>uvm_top的父辈是null，所以如果某个component的父辈是null，那么这个component的父类就是uvm_root类即uvm_top实例，这个comp就是casen，实例化名叫uvm_test_top</strong>；</p></li><li><p>层级结构的函数</p><ol><li>get_full_name，就可以得到该component的路径</li><li>get_parent</li><li>get_child需要string name</li><li>get_children获取所有孩子，参数是一个队列类型</li><li>get_first_child、get_next_child</li><li>get_num_children，获取component所拥有的所有孩子的数量</li></ol></li><li><p>field_automation机制具体的宏介绍、函数、标志位使用</p></li><li><p>UVM打印信息的控制</p><ol><li>UVM_INFO最后一个参数是冗余度</li><li>冗余度阈值UVM_LOW\MEDIUM\HIGH，低于该阈值的冗余度的信息都会被打印出来，支持在命令行设置阈值【+UVM_VERBOSITY&#x3D;HIGH】！</li><li>get_report_verbosity_level函数得到某个component的冗余度阈值</li><li>set_report_verbosity_level函数设定某个component的冗余度阈值，如果想把该component树节点的下层全部设定统一的冗余度阈值，用递归的设置函数set_report_verbosity_level_hier</li><li>set_report_id_verbosity函数区分不同ID的冗余度阈值，同样有递归</li><li>重载打印信息，比如将drv中的UVM_WARING重载为UVM_ERROR，用set_report_severity_id_override函数</li><li>UVM_FATAL出现会立马停止仿真，也可以统计UVM_ERROR达到多少个停止仿真，用set_report_quit_count(5)即出现5个ERROR就会退出，不必等到所有objection的撤销！【get_max_quit_count获取阈值5，得到0表示无论多少ERROR都不会退出仿真】，用set_report_severity_action(UVM_WARNING，UVM_DISPLAY(UVM_COUNT))把WARNING加入到计数中！</li></ol></li><li><p>config db机制，get_full_name会得到component的路径，所以component实例化时的名字就会出现在路径中，但是指针drv还是相对于casen的层次结构名，而不是实例化的名my_driver；</p><ol><li>主要用于传递参数，set&#x2F;get，第一、二参数是目标路径，符合路径的才会收到信！第三个参数是目标成员，第四个参数是设定的值或接收的值；</li><li>跨层次的多重设置，即设置多次，只获取一次，判断优先级：层次越高越优先，时间越到最后即越近的越优先，所以是uvm_test_top最优先，或者build_phase执行到最后的节点最优先</li><li>同一层次的多重设置，时间优先！</li><li>非直线的设置与获取，scb获取drv的config db参数就是非直线，如果按照层级结构来就是直线；需要仔细设定路径！同时由于build phase执行顺序在drv和scb是统一层级的，谁先谁后并不知道，所以设置的时候会有风险！不采用非直线会造成set的多次设置吗，即冗余浪费！</li><li>支持通配符</li></ol></li></ol><h1 id="第四章-TLM通信"><a href="#第四章-TLM通信" class="headerlink" title="第四章 TLM通信"></a>第四章 TLM通信</h1><ol><li><p>验证平台内部的通信方法有</p><ol><li>全局变量</li><li>在scb设置public变量，在mon直接赋值</li><li>config db传递object类，但是需要base_test参与设置，但是base_test派生类有可能会改变变量的值存在风险</li><li>如果有阻塞和非阻塞，上面完全不合适，也可以用sv的旗语、邮箱等实现，但是复杂</li><li>建立管道通信，信息只在管道内流动——TLM机制</li></ol></li><li><p>TLM；分1.0和2.0；事务级建模</p><ol><li>通信发起者与通信的目标</li><li>PUT是发起者把tr发送给目标，发起者具有port端口【方框表示】</li><li>GET是发起者要目标索要tr，目标具有export端口【圆圈表示】</li><li>PUT与GET的数据流向不同，但是发起者是一样的，都是A主动方，B被动方</li><li>transport操作，put+get，A向B提交请求，B回应了并返回</li><li>PUT GET TRANSPORT都有阻塞与非阻塞之分</li></ol></li><li><p>PORT和EXPORT，参数是数据流的类型，一般是tr</p><p>三个是指blocking，non_blocking，无</p><ol><li>put三个</li><li>get三个</li><li>transport三个</li><li>peek三个</li><li>get_peek三个</li></ol><p>PORT15个，EXPORT15个</p></li><li><p>建立连接关系，即连接管道【在env中连接】：发起者A.port.connect(被动方.export)，这只是连接管道，还没有通信【也没有存储tr的作用，只是转发tr而已】！connect之前要分别在各自的component通过new实例化好PORT和EXPORT，new的参数是名字+所在component【this即可】</p></li><li><p>IMP；实现tr的处理；与PORT类似，有15个，各自有阻塞非阻塞无三种，名字没具体的含义只是要求与对应的PORT或EXPORT连接对应的IMP</p><ol><li>PUT</li><li>GET</li><li>PEEK</li><li>GET_PEEK</li><li>TRANSPORT</li></ol><p>参数【tr，B_component】，即IMP需要在组件B中实现一个PUT函数或任务，因为A的PORT连接B的EXPORT，B的EXPORT连接B的IMP，B的imp会调用B的put函数任务完成tr的处理【这是put操作的举例】</p><p>IMP才是UVM中连接关系的终点！PORT优先级&gt;export&gt;imp</p></li><li><p>PORT与IMP连接</p></li><li><p>EXPORT与IMP连接</p></li><li><p>PORT与PORT连接</p></li><li><p>EXPORT与EXPORT连接</p></li><li><p>blocking_get，发起者B向A索要tr即GET操作，B中get任务最终会落到A中的get任务，所以A要有imp和export，还要有get任务！</p></li><li><p>non_blocking端口的使用是非堵塞的，要用函数实现！</p></li><li><p>第三种通信方式：analysis_port和analysis_export</p><ol><li><p>区别于blocking_put&#x2F;get端口，analysis_port可以一对多IMP【必须是analysis_imp类型】，广播！</p></li><li><p>没有堵塞和非堵塞的概念，就是广播！</p></li><li><p>analysis_port&#x2F;export只有一种操作就是write！【要在analysis_imp所在component定义好write函数！因为是port或export最终连到imp上，port或export的write操作最终由imp所在的component实现write函数，如果是fifo的话就不同了，无需定义write函数】</p></li><li><p>analysis_port&#x2F;export不能相互连接，必须终点是imp【fifo也是imp】</p></li><li><p>一个port，多个imp，如在scb中要接受mon和ref的数据，需要两个imp，可以用uvm_analysis_imp_decl分别连接并定义不同的imp和不同的write函数，后缀！</p></li><li><p>使用fifo通信：agt有analysis_port端口连接到FIFO【本质一块缓存加两个IMP口】的analysis_imp口，scb有blocking_get_port口连接FIFO的get_imp口，在env中分别连接</p><p>agt.ap.connect(fifo.analysis_export);</p><p>scb.exp_port.connect(fifo.blocking_get_export);</p><p>之所以用export是因为fifo把IMP掩饰成了export；</p><p>利用fifo后，不用在scb中定义write函数了！</p></li></ol></li></ol><h1 id="第五章-PHASE机制-OBJECTION机制"><a href="#第五章-PHASE机制-OBJECTION机制" class="headerlink" title="第五章 PHASE机制+OBJECTION机制"></a>第五章 PHASE机制+OBJECTION机制</h1><h2 id="PHASE机制"><a href="#PHASE机制" class="headerlink" title="PHASE机制"></a>PHASE机制</h2><ol><li>phase 细分了仿真的过程，不同的时间段做不同的事情！<ol><li>build_phase 函数型 完成实例化和config db操作</li><li>connect_phase 函数型</li><li>end_of_elaboration 函数型</li><li>start_of_simulation 函数型</li><li>run phase任务型，下面是12个动态运行phase，与run phase并行，同样是任务型<ol><li>pre_reset_phase</li><li>reset_phase 对DUT复位初始化操作，可以通过phase跳转转回reset phase</li><li>post_reset_phase</li><li>pre_configure_phase</li><li>configure_phase</li><li>post_configur_phase</li><li>pre_main_phase</li><li>main_phase</li><li>post_main_phase</li><li>pre_shutdown_phase</li><li>shut_down_phase</li><li>post_shut_down_phase</li></ol></li><li>extract_phase</li><li>check_phase</li><li>report_phase</li><li>final_phase</li></ol></li></ol><p>执行顺序自上而下【时间概念，不是build phase自下而上的空间概念】，函数phase同一时间只能执行一类；</p><p>除了build phase外，所有不消耗仿真时间的phase都是自下而上【空间概念】【函数型phase】，比如connect phase先执行底层的，最后执行顶层的connect phase；</p><p>从上得到了思考，为什么objection只在main phase提起和撤销【其实在动态运行12个phase中都可以，比如configure phase】，这是因为其他的phase是函数型，不消耗仿真时间，而raise objection操作一般放在不消耗仿真时间的最后面，放在第一个消耗仿真时间的前面！</p><ol><li>执行顺序，按照实例化的名字的字典序，针对drv和mon这种兄弟关系的同层级的phase而言！</li><li>对于同个component的执行顺序，12个动态运行phase是顺序执行的！比如先reset、configure接着main最后shutdown！</li><li>不同component的之间的相同phase类一定是一起结束！比如A的main phase先结束也要等B的main phase结束才算整个main phase的结束！</li><li>同个component的run phase和post shutdown phase一起结束！</li><li>不同的component，A的run phase一定和B的post shutdown phase或run phase一起结束！</li><li>所有component的run phase或post_shutdown_phase结束才会进入extract phase</li><li>叔侄关系的component的build phase执行顺序：UVM采用的是a！<ol><li>深度优先：agt&gt;scb，字典序，那么agt的build phase先执行，接着drv mon sqr由于d&gt;m&gt;s所以依次是drv mon sqr的buildphase执行完毕，然后执行兄弟scb的build phase【从始至终】</li><li>广度优先：agt&gt;scb，字典序，那么agt的build phase先执行，执行其他兄弟的，s应该在最后，因为s靠尾巴，所以scb的build phase靠后，兄弟的build phase执行完毕，接着开始agt的孩子，然后孩子的孩子！</li></ol></li><li>super.phase做了什么<ol><li>build phase，域的自动化机制注册变量字段+super.phase&#x3D;可以省略config db的get操作！</li><li>其他的phase没必要写super.phase！【适用直接扩展自uvm_component类，如果自定义类的phase写了一些东西并且子类需要继承的就不该省略】</li></ol></li><li>在end_of_elaboration、build phase、connect phase出现一个以上的UVM_ERROR，UVM认为出现了UVM_FATAL会停止仿真！【适用于大型设计，需要提前编译代码，不希望出现FATAL，只是希望编译后仿真的时候出现FATAL，可以用ERROR代替，这样编译的时候不会FATAL，只在仿真的时候FATAL，保留了编译的大量时间】</li><li>phase的跳转phase.jump(uvm_reset_phase::get())，一定要撤销objection清理掉！不然会报warning<ol><li>build_phase到start_of_simulation_phase不能作为跳转的参数</li><li>run_phase不能作为跳转的参数</li><li>pre_reset_phase一直到final_phase都可以做跳转参数</li></ol></li></ol><h2 id="Objection机制"><a href="#Objection机制" class="headerlink" title="Objection机制"></a>Objection机制</h2><ol><li><p>超时退出：某些测试case会挂起，仿真时间一直走，利用uvm_top.set_timeout函数设置超时退出时间【在base_test内定义】；超过此时间会给出FATAL退出仿真；在命令行也可以设置+UVM_TIMEOUT&#x3D;“300ns，YES”，YES代表覆盖define的超时时间设置宏</p></li><li><p>drop objection关闭验证平台，进入某个phase会收集该phase 提起的所有objection，并监测是否所有的drop objection都被撤销！接着关闭该phase！开始下一个phase的监测，所有phase监测完成后，调用$finish结束验证平台！</p><ol><li>drv的main phase提起了objection并且在100ns延迟后撤销了objection，与此同时，monitor的main phase正在无限循环某个函数，内部没有定义objection的提起与撤销，那么drv的objection撤销，UVM检查了所有objection已经撤销了就会关闭main phase，进入post main phase，所以进入post的时间是100ns，mon的无限循环会被强行杀死！</li><li>如果执行一些耗费时间的代码，在该phase下的任意个component提起和撤销objection！【objection伴随着seq，所以sequencer内的main phase提起和撤销objection，因为sqr启动seq后就代表转发完了seq产生的item，所以这时候撤销objection即可；或者用default_sequence方式挂载在某个component的mainphase或configurephase等上启动sequence【default_sequence会自动在对应sqr上seq.start(this)启动该sequence】，所以也可以用starting_phase≠null的方法在sequence内提起并延迟1000ns后继续撤销objection】</li></ol></li><li><p>12个动态运行phase中如果提起了objection，run phase会与它们并行运行；如果12个动态运行phase没有提起过objection，反而run phase中提起过objection，那么只会执行各个component的run phase，12个动态phase根本不会被执行【只针对耗时的代码】；所以12个动态运行phase的objection提起会影响run phase的运行，但是run phase的objection只会影响同类的run phase，不会让12个动态运行phase受影响的！【因为run phase大，12个动态phase小】</p><p>总结：先看12个小phase，有objection检测直到post_shutdown_phase，再看run phase的drop objection，最后关闭，进入extract phase</p><p>先看12个小phase，没有objection，看run phase的drop，最后关闭，进入extract phase</p></li><li><p>在scb或seq中控制objection，一般用seq中控制objection！</p></li><li><p>phase.phase_done.set_drain_time(this,200)，【为所有objection设置延时】，比如某个phase在所有objection被撤销后设置200ns的延时，后面如果没有再提起objection的phase，最终就到达了final_phase，<strong>一个phase对应一个drain_time!!!</strong></p></li></ol><h1 id="第六章-sequence"><a href="#第六章-sequence" class="headerlink" title="第六章 sequence"></a>第六章 sequence</h1><ol><li><p>sequence启动与执行；</p><ol><li>先实例化然后用start任务指明挂载的sqr【产生tr交给哪个sqr】</li><li>default_sequence利用config db【设定在哪个sqr的哪个phase内，设定实例化seq】启动【default自动在config db指定的sqr内部启动了对应的seq实例】</li><li>启动seq后会自动执行seq的body任务！【prebody和postbody】</li></ol></li><li><p>同一个sqr启动多个seq</p><ol><li>仲裁算法默认SEQ_ARB_FIFO，不考虑优先级，严格遵循先入先出规则</li><li>SEQ_ARB_STRICT_FIFO严格按照优先级【遵循seq中tr的uvm_do_pri设置的优先级】</li><li>sequence也有优先级，start(sqr,null,100)设定优先级【本质还是对seq内部的tr设定优先级！】</li><li>lock操作，seq向sqr发送请求都会被放入仲裁队列中，当lock前面的请求都处理完毕后，lock操作开始独占sqr，直到unlock，该seq才不会独占sqr要求其发送自己的tr了，后面的seq会交替产生tr，如果多个seq调用lock【时间优先，先发起的lock先开始】</li><li>grab操作，seq向sqr发送的请求放到冲裁队列最前方，即优先处理具有grap的seq的tr，【多个grap与lock一样遵循时间优先的原则】</li><li>grab前有lock，会等待lock结束，再将grab操作放入队列的最前方</li><li>sequence的有效性：sqr仲裁时会查看seq的is_relevant函数返回值【该函数可以重载然后自定义的】，如果为1，说明seq有效，否则无效！通过设置is_relevant可以使得sequence主动放弃sqr的使用权，即在一定时间范围内，seq不想发送tr给sqr！另外，wait_for_relevant是seq定义的，但是是sqr主动调用的；</li></ol></li><li><p>与sequence相关的宏</p><ol><li>uvm_do系列：基础是uvm_do_on_pri_with(tr, sqr, 优先级，约束{tr.xxx&#x3D;&#x3D; xxx})，第一个参数可以是tr或者是sequence，如果是tr会调用start_item和finish_item，如果是sequence，会调用start任务!类似的由uvm_send宏、uvm_rand_send、uvm_create</li><li>uvm_create与uvm_send分别实例化tr和发送tr</li><li>umv_rand_send系列：对已经实例化的tr进行随机化并发送，uvm_rand_send_pri_with(tr，优先级，约束)，主要意义在于前后发送的tr使用同一块内存内容不同而已，节省内存</li><li>不使用宏产生item的方法：start_item和finish_item，使用前要实例化item即tr。在start和finish中间随机化item——uvm_do的内容，指定优先级需要在start和finish同时加</li><li>pre_do mid_do post_do针对uvm_do而言</li></ol></li><li><p>嵌套sequence，在一个sequence的body调用定义好的另一个sequence【实例化+start】</p></li><li><p>sequence也可以定义rand变量，从而利用uvm_do参数为sequence时一样可以随机化【如果tr里面有同类型的rand变量会优先使用tr，sequence的同名变量会不考虑】</p></li><li><p>sequence发送的tr类型：一般一个sqr只能产生一种tr，如果将不同的tr交给同一个sqr，需要将sequencer和driver定义时的参数化类的参数改为uvm_sequence_item即tr的基类，这样sequence定义不同的tr句柄并进行随机化发送是可行的，但是drv中如果要引用不同tr的内部成员变量，需要将uvm_sequence_item通过cast转换成对应的tr如my_tr【cast(my_tr, req)，其中req是drv自带的成员变量，是与定义参数化类的参数相同即uvm_sequence_item】</p></li><li><p>sequence想要引用启动该seq所用的sequencer内的成员变量，需要通过m_sequencer；由于m_Sequencer继承于uvm_sequencer_base(uvm_Sequencer的基类)，所以如果sequencer想要引用比如my_sqr【前提是该seq在my_sqr上启动，所以m_Sequencer代表了该sequence启动后所使用的的sqr指针】的成员变量，相当于m_Sequencer要指向my_sqr，即基类句柄指向子类句柄，需要通过cast转换，转换成功的条件是基类句柄确确实实指向了子类的对象；所以整体流程是：声明my_sqr指针x_sqr，通过cast(x_Sqr, m_sequencer)转换，然后可以通过x_sqr调用my_Sqr的成员变量；【多态的特性，重点看看！】</p><p>上面的过程：由于使用到sqr的成员变量情况很多，所以uvm内建宏：uvm_declare_p_sequencer(my_sqr)，相当于声明了my_sqr指针p_sequencer+自动将m_sequencer转换为p_sequencer&#x3D;直接用p_sequencer引用成员变量</p></li><li><p>sequence之间的同步：virtual sequencer和virtual sequence，虚拟的意思表示vseq根本不发送tr，只是控制其他的sequence；virtual sequencer包含指向其他真实sqr的指针!</p><p>base_test要实例化virtual sequencer，并在connect phase中将v_sqr.xxx_sqr0&#x3D;env.agt.sqr即将真实的sqr赋值给相应vsqr内的对应指针！</p><p>在vseq的body中可以用uvm_do发送不同seq产生的tr，这里在vseq要uvm_declare_p_sequencer(my_vsqr)，即什么vsqr的指针p_sequencer，然后利用p_sequencer.xxx_sqr即直接引用了vsqr内部的成员变量【即对应的真实sqr指针】，一般不同的seq需要挂载到不同的p_sequencer.xxx_sqr0&#x2F;1&#x2F;2上；</p><p>上面不用uvm_do发送替换成手动启动seq也是一样的，手动启动seq可以自定义很多操作比如指定文件名等；</p><p>vseq的使用可以减少config db的使用【没用vseq之前，需要一个seq对应一个sqr，并声明成default_sequence设置相关参数，有多少sqr就需要设置多少default_sequence即同等数量的config_db，用了vseq后只需要一次configdb将default_sequence设置实例化vseq并挂载到vsqr上在vsqr的main_phase上启动即可】，降低出错概率，解决了seq的同步问题！</p></li><li><p>再谈objection的控制</p><ol><li>在sequencer【在其他component也可】的动态运行phase如main_phase手动raise和drop【seq.start(this)后面drop】</li><li>default_sequence【在某个component设置default_sequence，通过config db设置，路径是某个sqr的某个任务phase如my_sqr的main phase或configure phase等待，最后一个参数丄my_sequence::type_id::get()】，默认会自动在对应sqr的对应任务phase中【比如my_sqr.main phase】做出：seq.staring_phase&#x3D;phase【这里的phase就是main phase，所以phase不为null】，seq.start(this)，所以可以在sequence中通过判断if(staring_phase ！&#x3D; null)来提起和撤销objection，注意这里的starting_phase是uvm_sequence基类的成员变量，所以所有的seq都会该变量；</li><li>上面在seq内【假设是my_seq】通过starting_phase不为null提起和撤销objection，然后在objection关闭之前，使用uvm_do或者手动启动随机化tr发送出去都是可以的；但是如果在嵌套sequence中，即上面的my_seq在另一个seq中声明比如vseq，并在vseq通过uvm_do启动my_seq，这样会导致my_seq.starting_phase&#x3D;null，即不会提起objection，所以由此得出结论，最好在vseq中提起objection，统一调度的作用再次体现！</li></ol></li><li><p>sequence使用fork join_none慎用，因为none会直接endtask，杀死还未启动的seq进程，解决方法：wait_fork等待fork起来的进程执行完毕或者用for join【这样不能使用for循环了】</p></li><li><p>sequence使用config db；get_full_name()会返回component的路径或者返回某个sequence的sqr路径+实例化sequence时的名字；所以用通配符取代实例化sequence的名字，然后路径设为sqr的路径+通配符，即可set；那么get的话需要在sequence中用null或uvm_root::get()+get_full_name()+第三个参数+第四个参数的方式get</p></li><li><p>wait_modifield</p></li><li><p>response；与seq-sqr-drv单向数据传输机制不同，这里是seq-sqr-drv-sqr-seq，即drv会反馈信息给seq，其实是drv将rsp推给sqr，sqr内部有一个rsp队列，有新的rsp进入时就把rsp放入队列中，队列大小默认是8，超过8会给出错误提示【为什么会超过8因为一个tr可以有多个rsp，只要多次在seq中get_rsp和在drv中多次put_rsp，如果seq没有及时get_rsp，那么队列可能就会塞满rsp导致错误】；在seq使用get_rsp(rsp)函数，在drv使用put_rsp(rsp)函数【还要rsp.set_id_info(req)，即将req的id等信息复制到rsp，因为存在多个sequence在同一sqr上启动的情况，该操作保证了sqr知道将rsp数据返回给哪一个seq】</p></li><li><p>上面的seq_get操作启动时，会一直从sqr的rsp队列里中获取rsp，如果drv没有put_rsp且sqr的队列中rsp一直空的话，那么该进程会一直堵塞，从而导致drv无法获得seq发送的新的tr了，所以如果将get_rsp和put_rsp线程分开——response handler的用法</p></li><li><p>sequence_library；一系列sequence的集合，指明参数为tr，new函数调用int_sequence_library表示内部队列不空才可以把seq放进去，用uvm_add_to_seq_lib加入seq注册到图书馆中</p></li></ol><h1 id="第七章-寄存器模型"><a href="#第七章-寄存器模型" class="headerlink" title="第七章 寄存器模型"></a>第七章 寄存器模型</h1><p>• 来源：芯片验证工程师 • 2023-06-24 12:02 • 359次阅读</p><p><a href="https://www.elecfans.com/tags/%E5%AF%84%E5%AD%98%E5%99%A8/">寄存器</a>模型保持着DUT内部寄存器值的<strong>镜像（mirror）</strong>。</p><p>镜像值不能保证是正确的，因为寄存器模型只能感知到对这些寄存器的外部读写操作。</p><p>如果DUT内部修改了寄存器中的字段，镜像值就会<strong>过时（outdated）</strong>。</p><p>寄存器模型可以通过使用<strong>uvm_reg_field::mirror()</strong>, <strong>uvm_reg::mirror()</strong>, 或**uvm_reg_block::mirror()**方法将一个寄存器的镜像值更新为存储在DUT中的值。</p><p>更新寄存器中某个字段的镜像也会同时更新同一寄存器中所有其他字段的镜像。更新一个block的镜像会更新它包含的所有寄存器和字段的镜像。</p><p>如果使用<strong>前门访问</strong>，更新一个大block的镜像可能需要大量的<a href="https://bbs.elecfans.com/zhuti_proteus_1.html">仿真</a>时间；而使用<strong>后门访问</strong>更新不需要消耗仿真时间。</p><p>可以通过使用<strong>uvm_reg_field::set()<strong>或</strong>uvm_reg::set()<strong>方法在不消耗仿真时间向寄存器模型中的写入镜像值，</strong>这个镜像值不会反应到DUT中相应字段或寄存器</strong>。</p><p>可以通过使用**uvm_reg::update()<strong>或</strong>uvm_reg_block::update()**方法更新DUT的寄存器以匹配镜像值。如果新的镜像值与旧的镜像值相匹配，寄存器就不会被更新，从而节省不必要的总线访问。</p><p>要想不消耗仿真时间访问一个field或register的当前镜像值，可以使用 <strong>uvm_reg_field::get()</strong> 或**uvm_reg::get()**方法。</p><p><strong>Mem<a href="https://m.hqchip.com/app/1716">or</a>ies是没有镜像的</strong></p><p>Memories比较大，所以通常使用<strong>稀疏阵列</strong>的方法来建模。只有被写入的位置才会被存储起来，然后再读回来。任何未使用的内存位置都不会被建模。</p><p>与寄存器不同，memory的行为非常简单，memory镜像将是一个<a href="https://www.elecfans.com/tags/rom/"><strong>ROM</strong></a>或<a href="https://www.elecfans.com/tags/ram/"><strong>RAM</strong></a>内存模型，所以可以通过提供对内存模型的后门访问来取代。因此，使用<strong>uvm_mem::peek()<strong>或</strong>uvm_mem::poke()<strong>方法提供与memory镜像完全相同的功能。此外，与基于观察到的读写操作的寄存器镜像不同，使用后门访问的memory镜像总是返回或设置DUT中一个内存位置的</strong>实际值</strong>。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;UVM白皮书复习&quot;&gt;&lt;a href=&quot;#UVM白皮书复习&quot; class=&quot;headerlink&quot; title=&quot;UVM白皮书复习&quot;&gt;&lt;/a&gt;UVM白皮书复习&lt;/h1&gt;&lt;h1 id=&quot;第二章&quot;&gt;&lt;a href=&quot;#第二章&quot; class=&quot;headerlink&quot; ti</summary>
      
    
    
    
    <category term="IC" scheme="https://vliamzh.github.io/categories/IC/"/>
    
    <category term="UVM" scheme="https://vliamzh.github.io/categories/IC/UVM/"/>
    
    
    <category term="UVM" scheme="https://vliamzh.github.io/tags/UVM/"/>
    
    <category term="DV" scheme="https://vliamzh.github.io/tags/DV/"/>
    
  </entry>
  
  <entry>
    <title>idea收集</title>
    <link href="https://vliamzh.github.io/2024/08/04/idea%E6%94%B6%E9%9B%86/"/>
    <id>https://vliamzh.github.io/2024/08/04/idea%E6%94%B6%E9%9B%86/</id>
    <published>2024-08-04T06:39:30.000Z</published>
    <updated>2024-08-04T07:22:19.581Z</updated>
    
    <content type="html"><![CDATA[<h3 id="Internet-provides-the-window-so-that-we-can-easily-see-the-world"><a href="#Internet-provides-the-window-so-that-we-can-easily-see-the-world" class="headerlink" title="Internet provides the window so that we can easily see the world!"></a>Internet provides the window so that we can easily see the world!</h3><ol><li>source: <a href="https://www.reddit.com/r/ECE/comments/1ehfnrb/starting_a_new_semester_these_are_the_courses_if/?utm_source=share&utm_medium=web3x&utm_name=web3xcss&utm_term=1&utm_content=share_button">https://www.reddit.com/r/ECE/comments/1ehfnrb/starting_a_new_semester_these_are_the_courses_if/?utm_source=share&amp;utm_medium=web3x&amp;utm_name=web3xcss&amp;utm_term=1&amp;utm_content=share_button</a></li></ol><blockquote><p>I don’t even have to look at the courses. The advice is pretty much always the same. Study hard and be methodical. Organise your timetable and try to work an 8 hour day with the same start and end time per day. You may have to go over that but try not to go too much over too often, burn out is real. This time includes your lectures, but not travel time.</p><p>Before each lecture read any notes you’ve been given in advance for that lecture. If you haven’t been given any then try to look up last years notes, or at worst figure out the topic and make a stab figuring out the correct chapter of the suggested reading list. The idea is to go into the class with enough of an idea of what the class is about and to have already understood the simple stuff. This way you can concentrate on the important things your lecturer is saying rather than struggling over that equation they wrote on the board 10 minutes ago. Additionally you can identify areas you don’t understand and pay special attention during that part of the class. If they don’t explain it, you can ask for clarification, and you can do so with confidence that your question is not dumb given you’ve put some thought into it.</p><p>Then after the class go over all the notes and the reading material again. If you’re still struggling with a topic or have new questions, make use of your lecturer’s office hours &#x2F; research online, etc.. until you get it figured out. Then write up your notes in a neat organised fashion. Maintain two documents: your full notes and a cheat sheet for use when doing your homework &#x2F; practice exams, and if permitted in the real exams.</p><p>That’s how you handle lectures to get the maximum benefit from them.</p><p>As for managing the work load of course work, gets started early, work on whatever is due first that you’re not otherwise blocked on. If you are blocked, work to get unblocked should be high priority. When something is done to a good enough standard move on to the next task. If you have spare time before the deadline go back and tweak it and improve it.</p></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;Internet-provides-the-window-so-that-we-can-easily-see-the-world&quot;&gt;&lt;a href=&quot;#Internet-provides-the-window-so-that-we-can-easily-see-t</summary>
      
    
    
    
    <category term="其它" scheme="https://vliamzh.github.io/categories/%E5%85%B6%E5%AE%83/"/>
    
    <category term="idea" scheme="https://vliamzh.github.io/categories/%E5%85%B6%E5%AE%83/idea/"/>
    
    
    <category term="idea" scheme="https://vliamzh.github.io/tags/idea/"/>
    
    <category term="收集" scheme="https://vliamzh.github.io/tags/%E6%94%B6%E9%9B%86/"/>
    
  </entry>
  
  <entry>
    <title>Linux自用</title>
    <link href="https://vliamzh.github.io/2024/07/14/Linux%E8%87%AA%E7%94%A8/"/>
    <id>https://vliamzh.github.io/2024/07/14/Linux%E8%87%AA%E7%94%A8/</id>
    <published>2024-07-14T15:45:09.000Z</published>
    <updated>2024-08-01T14:34:44.920Z</updated>
    
    <content type="html"><![CDATA[<h1 id="自用虚拟机Vmware的Linux-Centos："><a href="#自用虚拟机Vmware的Linux-Centos：" class="headerlink" title="自用虚拟机Vmware的Linux-Centos："></a>自用虚拟机Vmware的Linux-Centos：</h1><h1 id="一、Linux常用"><a href="#一、Linux常用" class="headerlink" title="一、Linux常用"></a>一、Linux常用</h1><p>来源：<a href="https://www.runoob.com/w3cnote/linux-useful-command.html">菜鸟教程</a></p><p><img src="https://cdn.jsdelivr.net/gh/vliamzh/image@main/image/202407142328285.png" alt="Linux常用操作"></p><h1 id="二、自用的Linux-Centos"><a href="#二、自用的Linux-Centos" class="headerlink" title="二、自用的Linux-Centos"></a>二、自用的Linux-Centos</h1><ol><li>虚拟机Vmware实现</li><li>输入法：Ibus，切换使用win+space</li><li>SHELL：zsh</li><li>终端：xfce4</li><li><strong>使用neofetch查看系统信息</strong></li></ol><ul><li>使用sudo yum install neofetch安装，然后neofetch查看linux环境信息</li><li>安装epel-release &gt; yum install epel-release</li><li>添加第三方软件源 &gt; curl -o &#x2F;etc&#x2F;yum.repos.d&#x2F;konimex-neofetch-epel-7.repo <a href="https://copr.fedorainfracloud.org/coprs/konimex/neofetch/repo/epel-7/konimex-neofetch-epel-7.repo">https://copr.fedorainfracloud.org/coprs/konimex/neofetch/repo/epel-7/konimex-neofetch-epel-7.repo</a></li><li>使用包管理器安装 neofetch &gt; sudo yum install neofetch</li><li>运行 &gt; neofetch</li></ul><p><img src="https://cdn.jsdelivr.net/gh/vliamzh/image@main/image/202407142328960.png" alt="界面展示"></p><h1 id="三、一些必备设置"><a href="#三、一些必备设置" class="headerlink" title="三、一些必备设置"></a>三、一些必备设置</h1><h2 id="1-Linux命令行移动光标"><a href="#1-Linux命令行移动光标" class="headerlink" title="1.Linux命令行移动光标"></a>1.Linux命令行移动光标</h2><p><img src="https://cdn.jsdelivr.net/gh/vliamzh/image@main/image/202407160042906.png" alt="命令行"><img src="https://cdn.jsdelivr.net/gh/vliamzh/image@main/image/202407160043852.png" alt="命令行"></p><h2 id="2-终端设置"><a href="#2-终端设置" class="headerlink" title="2.终端设置"></a>2.终端设置</h2><pre><code class="shell">#如果是csh，在cshrc中alias cd &#39;cd \!*; ls;&#39;#如果是bash，在bashrc中cd()&#123;builtin cd &quot;$@&quot; &amp;&amp; ls&#125;#如果是zsh，在zshrc中function cd() &#123;    emulate -LR zsh    builtin cd $@ &amp;&amp;    ls -a&#125;#如何查询SHELLecho $SHELL</code></pre><h2 id="3-git设置"><a href="#3-git设置" class="headerlink" title="3.git设置"></a>3.git设置</h2><p>参考：<a href="https://zhuanlan.zhihu.com/p/688103044">https://zhuanlan.zhihu.com/p/688103044</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;自用虚拟机Vmware的Linux-Centos：&quot;&gt;&lt;a href=&quot;#自用虚拟机Vmware的Linux-Centos：&quot; class=&quot;headerlink&quot; title=&quot;自用虚拟机Vmware的Linux-Centos：&quot;&gt;&lt;/a&gt;自用虚拟机Vmware</summary>
      
    
    
    
    <category term="Linux" scheme="https://vliamzh.github.io/categories/Linux/"/>
    
    <category term="Linux自用" scheme="https://vliamzh.github.io/categories/Linux/Linux%E8%87%AA%E7%94%A8/"/>
    
    
    <category term="Linux" scheme="https://vliamzh.github.io/tags/Linux/"/>
    
    <category term="Vmware" scheme="https://vliamzh.github.io/tags/Vmware/"/>
    
  </entry>
  
  <entry>
    <title>效率软件</title>
    <link href="https://vliamzh.github.io/2024/07/14/%E6%95%88%E7%8E%87%E8%BD%AF%E4%BB%B6/"/>
    <id>https://vliamzh.github.io/2024/07/14/%E6%95%88%E7%8E%87%E8%BD%AF%E4%BB%B6/</id>
    <published>2024-07-14T15:00:50.000Z</published>
    <updated>2024-08-09T16:33:25.583Z</updated>
    
    <content type="html"><![CDATA[<ul><li>quicker，配合沙拉查词可以实现翻译</li><li>PowerToys，微软出品，各种工具箱，并且慢慢集成了很多插件，比如Everything</li><li>Everything，全局搜索</li><li>Ditto，剪切板历史保存</li><li>Clash Verge</li><li>Quicklook，快速预览，本来配合Zotero使用，但是未来不做学术了，所以不必，但是这个功能PowerToys中自带</li><li>PixPin，代替Snipaste的截图软件</li><li>TranslucentTB，任务栏变透明的小软件</li><li>PicGo，配合typera实现github图床，写博客很方便</li><li>XmouseButtonControl，调节鼠标滑动灵敏度，配合不同的PDF阅读器使用</li><li>Dism++，系统调教的神</li><li>sizer， 窗口大小更改，右键到窗口最大化位置选择尺寸</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;ul&gt;
&lt;li&gt;quicker，配合沙拉查词可以实现翻译&lt;/li&gt;
&lt;li&gt;PowerToys，微软出品，各种工具箱，并且慢慢集成了很多插件，比如Everything&lt;/li&gt;
&lt;li&gt;Everything，全局搜索&lt;/li&gt;
&lt;li&gt;Ditto，剪切板历史保存&lt;/li&gt;
&lt;l</summary>
      
    
    
    
    <category term="重装电脑" scheme="https://vliamzh.github.io/categories/%E9%87%8D%E8%A3%85%E7%94%B5%E8%84%91/"/>
    
    <category term="效率软件" scheme="https://vliamzh.github.io/categories/%E9%87%8D%E8%A3%85%E7%94%B5%E8%84%91/%E6%95%88%E7%8E%87%E8%BD%AF%E4%BB%B6/"/>
    
    
    <category term="效率" scheme="https://vliamzh.github.io/tags/%E6%95%88%E7%8E%87/"/>
    
    <category term="必装" scheme="https://vliamzh.github.io/tags/%E5%BF%85%E8%A3%85/"/>
    
  </entry>
  
  <entry>
    <title>VCS工具</title>
    <link href="https://vliamzh.github.io/2024/07/14/VCS%E5%B7%A5%E5%85%B7/"/>
    <id>https://vliamzh.github.io/2024/07/14/VCS%E5%B7%A5%E5%85%B7/</id>
    <published>2024-07-14T14:33:22.000Z</published>
    <updated>2024-07-14T14:56:14.864Z</updated>
    
    <content type="html"><![CDATA[<p>参考：</p><p><a href="https://blog.csdn.net/Tranquil_ovo/article/details/131797045">VCS仿真基础</a></p><p>这个专栏还有覆盖率的介绍，可以看看</p><p><a href="https://blog.csdn.net/Tranquil_ovo/article/details/131926080">Code Coverage</a></p><p><a href="https://www.cnblogs.com/Icer-newer/p/17056466.html"> Icer_Newer博客园</a> PS: 也有许多验证的知识分享，虽然大部分知识点重合。</p><p>VCS编译选项，网上很多，随便贴几个吧，如下：</p><p><a href="https://www.cnblogs.com/jason20/p/12874742.html">VCS常用仿真选项开关及步骤总结</a></p><p><a href="https://blog.csdn.net/qq_40571921/article/details/122159598">VCS和UVM常用编译选项</a></p><h1 id="一、工作过程"><a href="#一、工作过程" class="headerlink" title="一、工作过程"></a>一、工作过程</h1><ol><li>读取所有的 initial、always 、assgin 等语句，按照空间顺序放在队列里面。首先执行没有延时的语句（如变量的初始化赋值等）</li><li>执行完没有延时的语句之后，将时间 t 设为 0，称之为 current time。</li><li>然后，首先进入 active region。<br>在该区域内，VCS执行的操作包括：<br>① 原语（或门、非门、CMOS逻辑、PMOS逻辑、上拉、下拉 …）；<br>② $display；<br>③ 不包含任何延时信息的 assgin 语句；<br>④ 阻塞赋值（ &#x3D; ）；<br>⑤ 非阻塞赋值（ &lt;&#x3D; ）只计算右边的表达式，不进行赋值操作</li><li>进入 inactive region<br>执行带有 #0 的语句。<br>虽然没有延时，但是对于VCS而言，这种语句会比没有使用 # 设置延时的语句的执行时间晚一些。</li><li>进入 Nonblocking assgin region<br>对非阻塞赋值语句进行赋值操作</li><li>monitor region<br>monitor 系统函数是只有在变量发生变化的时候才会执行。</li><li>future region<br>执行其他语句</li></ol><p><img src="https://cdn.jsdelivr.net/gh/vliamzh/image@main/image/202407142240565.png" alt="仿真事件队列"></p><p><img src="https://cdn.jsdelivr.net/gh/vliamzh/image@main/image/202407142240254.png" alt="详细工作流程"></p><p>（1）将 Verilog&#x2F;SV 翻译为 C 语言中间文件<br>（2）将 C 语言文件编译为对象文件（.o）<br>（3）连接后形成可执行文件</p><p>举例说明：</p><p><img src="https://cdn.jsdelivr.net/gh/vliamzh/image@main/image/202407142243370.png" alt="编译过程"></p><p>针对宏的编译：</p><p><img src="https://cdn.jsdelivr.net/gh/vliamzh/image@main/image/202407142245225.png" alt="针对宏的编译需要加命令"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;参考：&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://blog.csdn.net/Tranquil_ovo/article/details/131797045&quot;&gt;VCS仿真基础&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;这个专栏还有覆盖率的介绍，可以看看&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;ht</summary>
      
    
    
    
    <category term="IC" scheme="https://vliamzh.github.io/categories/IC/"/>
    
    <category term="VCS工具" scheme="https://vliamzh.github.io/categories/IC/VCS%E5%B7%A5%E5%85%B7/"/>
    
    
    <category term="vcs" scheme="https://vliamzh.github.io/tags/vcs/"/>
    
    <category term="verdi" scheme="https://vliamzh.github.io/tags/verdi/"/>
    
  </entry>
  
  <entry>
    <title>git使用</title>
    <link href="https://vliamzh.github.io/2024/07/13/git%E4%BD%BF%E7%94%A8/"/>
    <id>https://vliamzh.github.io/2024/07/13/git%E4%BD%BF%E7%94%A8/</id>
    <published>2024-07-13T07:43:13.000Z</published>
    <updated>2024-08-04T16:14:11.980Z</updated>
    
    <content type="html"><![CDATA[<h1 id="git使用"><a href="#git使用" class="headerlink" title="git使用"></a>git使用</h1><p>参考：</p><p><a href="https://zhuanlan.zhihu.com/p/132573100">工作流一目了然，看小姐姐用动图展示10大Git命令 - 知乎 (zhihu.com)</a></p><p><a href="https://www.runoob.com/git/git-tutorial.html">菜鸟教程-git教程</a></p><p><a href="https://blog.csdn.net/Sky_Tree_Delivery/article/details/117329525">git常用23条命令总结</a></p><p><a href="https://www.jianshu.com/p/e57a4a2cf077">git使用教程</a></p><p><a href="http://www.mybatis.cn/git/index.html">MyBatis中文官网关于git的介绍</a> 该网站还有关于vim的介绍<a href="http://www.mybatis.cn/vim/index.html">vim入门教程</a></p><h2 id="1-分区"><a href="#1-分区" class="headerlink" title="1.分区"></a>1.分区</h2><p><img src="https://cdn.jsdelivr.net/gh/vliamzh/image@main/image/202407131553300.png"></p><h3 id="1-git的由来"><a href="#1-git的由来" class="headerlink" title="1. git的由来"></a>1. git的由来</h3><p>Git更像是把数据看作是对小型文件系统的一系列快照。在Git中，每当你提交更新或保存项目状态时，它基本上就会对当时的全部文件创建一个快照并保存这个快照的索引。另外，如果文件没有修改，Git不再重新存储该文件，而是只保留一个链接指向之前存储的文件。<strong>Git对待数据更像是一个快照流</strong>。</p><p><img src="https://cdn.jsdelivr.net/gh/vliamzh/image@main/image/202407131613687.png" alt="SVN等以文件变化方式储存信息"><img src="https://cdn.jsdelivr.net/gh/vliamzh/image@main/image/202407131612350.png" alt="Git以文件快照方式储存信息"></p><p><strong>实际上，Git仓库中保存的信息都是以文件内容的哈希值来索引，而不是文件名。</strong></p><p><img src="https://cdn.jsdelivr.net/gh/vliamzh/image@main/image/202407131629897.jpeg" alt="img"></p><h3 id="2-git的5种状态"><a href="#2-git的5种状态" class="headerlink" title="2. git的5种状态"></a>2. git的5种状态</h3><ul><li>未修改(Origin)</li><li>已修改(Modified)，已表示修改了文件，但还没保存到仓库中。</li><li>已暂存(Staged)，表示对一个已修改文件的当前版本做了标记，使之包含在下次提交的快照中。</li><li>已提交(Committed)，表示文件已经安全地保存在本地仓库中。</li><li>已推送(Pushed)，表示文件已经从本地仓库已经推送到远端仓库中。</li></ul><h3 id="3-git的分支"><a href="#3-git的分支" class="headerlink" title="3. git的分支"></a>3. git的分支</h3><p><img src="https://cdn.jsdelivr.net/gh/vliamzh/image@main/image/202407131757078.jpeg" alt="git分支是一个串联的链表"></p><p>HEAD指向的是当前正在操作的分支，HEAD -&gt; master 告诉我们当前处于 master 分支，HEAD也能代表当前分支最新提交的commit id。有时候，我们commit提交代码后，发现这一次commit的内容是有错误的，面对这种情况有两种解决方法：</p><blockquote><p>解决方法1：修改错误内容，再次commit一次</p><p>解决方法2：使用git reset命令撤销这一次错误的commit</p></blockquote><p>此时，该head出场了，它常常与reset连用，如下所示：</p><pre><code class="git">$ git reset HEAD &lt;file&gt;</code></pre><p>因为head表示当前分支的最新提交的commit id，上述命令的目的是将文件file恢复到指定的commit id。<br><img src="https://cdn.jsdelivr.net/gh/vliamzh/image@main/image/202407131759512.jpeg" alt="新建dev分支"></p><p>分支切换命令为：</p><pre><code class="git">git checkout branchname</code></pre><p><img src="https://cdn.jsdelivr.net/gh/vliamzh/image@main/image/202407131802108.jpeg" alt="dev分支生长会变得越来越远，B0是最开始提交"></p><p><img src="https://cdn.jsdelivr.net/gh/vliamzh/image@main/image/202407131804269.jpeg" alt="合并dev分支到master"><img src="https://cdn.jsdelivr.net/gh/vliamzh/image@main/image/202407131812868.png" alt="image-20240713181256782"></p><p>合并冲突现象：</p><p><img src="https://cdn.jsdelivr.net/gh/vliamzh/image@main/image/202407131804635.jpeg" alt="dev和master共同祖先B2,然后对同一文件进行了修改分别是B3、B4，需要手动合并"></p><p><img src="https://cdn.jsdelivr.net/gh/vliamzh/image@main/image/202407131805635.jpeg" alt="手动解决冲突，产生新快照B5"><img src="https://cdn.jsdelivr.net/gh/vliamzh/image@main/image/202407131813457.png" alt="合并冲突"></p><p>冲突的格式是这样的：</p><pre><code class="git">&lt;&lt;&lt;&lt;&lt;&lt;&lt; HEADtest master.=======test dev.&gt;&gt;&gt;&gt;&gt;&gt;&gt; dev</code></pre><p>冲突是通过&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;来分割的，其上部分表示HEAD分支的内容，其下部分表示dev分支的内容，这两部分内容发生了冲突。为了解决冲突，你必须选择使用由 &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D; 分割的两部分中的一个或者也可以自行合并这些内容。</p><blockquote><p>备注：通过上文Git的HEAD介绍，我们知道，HEAD指向的是当前正在操作的分支。因为运行合并命令（merge 命令）在 master 分支，所以 HEAD 指的是 master分支。</p><p>参考链接：&#x3D;&#x3D;<strong><a href="https://blog.csdn.net/qq_42780289/article/details/97945300">Git：合并分支—-git merge命令应用的三种情景</a></strong>&#x3D;&#x3D;</p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/vliamzh/image@main/image/202407131816026.png" alt="git分支命令"><img src="https://cdn.jsdelivr.net/gh/vliamzh/image@main/image/202407132233731.png" alt="git分支命令"></p><h2 id="2-常用操作"><a href="#2-常用操作" class="headerlink" title="2. 常用操作"></a>2. 常用操作</h2><table><thead><tr><th>常用命令</th><th>含义</th></tr></thead><tbody><tr><td>git config –global user.name 用户名</td><td>设置用户名</td></tr><tr><td>git config –global user.email 邮箱</td><td>设置用户邮箱</td></tr><tr><td>git init</td><td>初始化本地库</td></tr><tr><td>git status</td><td>查看本地库状态</td></tr><tr><td>git add 文件名</td><td>添加到暂存区</td></tr><tr><td>git commit-m “日志信息” 文件名</td><td>提交到本地库</td></tr><tr><td>git reflog&#x2F;git log</td><td>查看历史记录</td></tr><tr><td>git reset –hard 版本号</td><td>版本穿梭</td></tr><tr><td>git stash</td><td>将暂存器和工作区内容保存</td></tr><tr><td>git stash pop</td><td>恢复之前的工作编辑状态</td></tr></tbody></table><p>参考图：<a href="https://blog.csdn.net/molangmolang/article/details/137111309">git常用命令速查</a></p><p><img src="https://cdn.jsdelivr.net/gh/vliamzh/image@main/image/202407131838555.png" alt="《Git常用命令》详细讲解·第10篇（git fetch、git pull和git push）"></p><p>具体：</p><h3 id="1-git-config"><a href="#1-git-config" class="headerlink" title="(1)git config"></a>(1)git config</h3><p><img src="https://cdn.jsdelivr.net/gh/vliamzh/image@main/image/202407131823281.png" alt="git config"></p><h3 id="2-git-stash"><a href="#2-git-stash" class="headerlink" title="(2)git stash"></a>(2)git stash</h3><p><img src="https://cdn.jsdelivr.net/gh/vliamzh/image@main/image/202407131825309.png" alt="git stash"><img src="https://cdn.jsdelivr.net/gh/vliamzh/image@main/image/202407131830354.png" alt="git stash总结"></p><h3 id="3-git-diff"><a href="#3-git-diff" class="headerlink" title="(3)git diff"></a>(3)git diff</h3><p><img src="https://cdn.jsdelivr.net/gh/vliamzh/image@main/image/202407131833814.png" alt="git diff"></p><h3 id="4-git-checkout"><a href="#4-git-checkout" class="headerlink" title="(4)git checkout"></a>(4)git checkout</h3><p><img src="https://cdn.jsdelivr.net/gh/vliamzh/image@main/image/202407131834956.png" alt="git checkout"></p><h3 id="5-git-log"><a href="#5-git-log" class="headerlink" title="(5)git log"></a>(5)git log</h3><p><img src="https://cdn.jsdelivr.net/gh/vliamzh/image@main/image/202407131835163.png" alt="git log"></p><p>git log 命令有众多的参数，选择合理的参数，可以方便查看过往的仓库提交历史记录。主要的参数有：<code>--oneline</code>、<code>--stat</code>、<code>--author</code>、<code>--after</code>、<code>--before</code>，还有<code>-p</code>、<code>-n</code>。</p><p>####–oneline 参数：简化默认的输出</p><p><code>--oneline</code> 参数用于简化 git log 的默认的输出，仅仅输出 commit hash 前7个字符串和 commit message。如下所示：</p><pre><code class="git">$ git log --oneline658ac24 modify some code in xxx section9d05208 modify some code in xxx section cb53d27 modify some code in xxx section</code></pre><h4 id="–stat-参数：增加增删的统计数据"><a href="#–stat-参数：增加增删的统计数据" class="headerlink" title="–stat 参数：增加增删的统计数据"></a>–stat 参数：增加增删的统计数据</h4><p><code>--stat</code> 参数是在 git log 的基础上输出文件增删改的统计数据，方便我们查看仓库的改动情况。如下所示：</p><pre><code class="git">$ git log --statcommit a8d08c1b60c0cbaa0be56378aa891726c45f0a49 Author: Tim &lt;xxx@mail.com&gt;Date:   Fri Oct 28 18:58:39 2022 +0800    modify some code in xxx section lib/common/Localized.dart         |   2 +- lib/pages/calendar_plan_page.dart | 470 ++++++++++++++++++++--------------- 2 files changed, 248 insertions(+), 224 deletions(-)</code></pre><h4 id="–author-参数：过滤作者"><a href="#–author-参数：过滤作者" class="headerlink" title="–author 参数：过滤作者"></a>–author 参数：过滤作者</h4><p>在团队合作开发过程中，如果只想查看某个小伙伴提交的代码，怎么办呢？此时可以加上 <code>--author</code> 参数用来过滤 commit，限定输出给定的用户，如下所示：</p><pre><code class="git">$ git log --author=&quot;Tim&quot;commit 84b86471ea12bd1f5994d878a318dcdead1137e9Author: Tim &lt;xxx@mail.com&gt;Date:   Wed Dec 19 17:29:25 2022 -0800    modify some code in xxx section</code></pre><h4 id="–after和–before-参数：限定指定日期范围的日志"><a href="#–after和–before-参数：限定指定日期范围的日志" class="headerlink" title="–after和–before 参数：限定指定日期范围的日志"></a>–after和–before 参数：限定指定日期范围的日志</h4><p>如果我们想看某段时间内的提交历史，可以使用 <code>--after</code> 和 <code>--before</code> 参数，十分好用，如下所示。不过，需要注意日期的格式，是<code>10-1-2022</code>这样的形式，国外风格的日期表示形式。</p><pre><code class="git">$ git log --after &#39;10-1-2022&#39;commit a8d08c1b60c0cbaa0be56378aa891726c45f0a49 (HEAD -&gt; dev, origin/dev, origin/HEAD)Author: Tim &lt;xxx@mail.com&gt;Date:   Fri Oct 28 18:58:39 2022 +0800    modify some code in xxx section...</code></pre><h4 id="p-参数：输出每次提交的内容差异"><a href="#p-参数：输出每次提交的内容差异" class="headerlink" title="-p 参数：输出每次提交的内容差异"></a>-p 参数：输出每次提交的内容差异</h4><p><code>-p</code> 参数很常用，它能控制输出每个 commit 具体修改的内容，输出的形式以 diff 的形式给出。如下所示：</p><pre><code class="git">$ git log -pcommit a8d08c1b60c0cbaa0be56378aa891726c45f0a49Author: Tim &lt;xxx@mail.com&gt;Date:   Fri Oct 28 18:58:39 2022 +0800    modify some code in xxx sectiondiff --git a/lib/common/Localized.dart b/lib/common/Localized.dartindex c870ab8..1992ccf 100644--- a/lib/common/Localized.dart+++ b/lib/common/Localized.dart</code></pre><h4 id="n-参数：限定log输出的条数"><a href="#n-参数：限定log输出的条数" class="headerlink" title="-n 参数：限定log输出的条数"></a>-n 参数：限定log输出的条数</h4><p>如果想看最近的 n 条提交日志，怎么办？很简单。直接在 log 命令之后，加 <code>-n</code> 参数即可，<code>n</code> 表示用户要输出的数量.</p><pre><code class="git">$ git log -n 3 commit a8d08c1b60c0cbaa0be56378aa891726c45f0a49Author: Tim &lt;xxx@mail.com&gt;Date:   Fri Oct 28 18:58:39 2022 +0800    modify some code in xxx section...</code></pre><h2 id="3-Git文件种类"><a href="#3-Git文件种类" class="headerlink" title="3. Git文件种类"></a>3. Git文件种类</h2><ul><li>已追踪的Tracked：已经在版本库中的文件，或者是已经暂存到索引中的文件。如果想将新文件newfile添加到为已追踪（Tracked）的文件，执行git add newfile命令即可。</li><li>被忽略的Ignored：</li><li>未追踪的Untracked：。Git把工作目录下的所有文件当成一个集合，减去已追踪的文件和被忽略的文件，剩余部分最为未被追踪的文件（Untracked）。</li></ul><h2 id="4-解释"><a href="#4-解释" class="headerlink" title="4. 解释"></a>4. 解释</h2><h3 id="1-git-init会生产一个-git文件夹"><a href="#1-git-init会生产一个-git文件夹" class="headerlink" title="1. git init会生产一个.git文件夹"></a>1. <code>git init</code>会生产一个.git文件夹</h3><h3 id="2-git-status会有git给我们的建议"><a href="#2-git-status会有git给我们的建议" class="headerlink" title="2. git status会有git给我们的建议"></a>2. <code>git status</code>会有git给我们的建议</h3><ol><li><p>On branch master: 我们位于一个叫做“master”的分支里，这是默认的分支，nothing to commit, working directory clean : 说明你的工作目录目前是“干净的”，没有需要提交的文件（意思就是自上次提交后，工作目录中的内容压根儿就没改动过）。</p></li><li><p><strong>Untracked files</strong> 说明存在未跟踪的文件，所谓的“未跟踪”文件，是指那些新添加的并且未被加入到暂存区域或提交的文件。它们处于一个逍遥法外的状态，但你一旦将它们加入暂存区域或提交到 Git 仓库，它们就开始受到 Git 的“跟踪”。</p></li></ol><h3 id="3-暂存区-工作区-版本库-暂存区-工作区"><a href="#3-暂存区-工作区-版本库-暂存区-工作区" class="headerlink" title="3. 暂存区-&gt;工作区 | 版本库-&gt;暂存区&#x2F;工作区"></a>3. 暂存区-&gt;工作区 | 版本库-&gt;暂存区&#x2F;工作区</h3><p>1、使用<code>git checkout</code>命令可以使<strong>暂存区的文件替换工作区的文件</strong>（暂存区域的旧版本覆盖工作目录的新版本，危险操作：相当于丢弃工作目录的修改）。</p><p><strong>如果暂存区有旧版本文件，工作区是新版本的修改后的文件，那么需要先执行 add 命令覆盖暂存区域，然后再提交……</strong></p><p>2、使用<code>git reset</code>命令可以回退版本。</p><h2 id="5-Git-本地仓库与远程仓库建立连接"><a href="#5-Git-本地仓库与远程仓库建立连接" class="headerlink" title="5. Git 本地仓库与远程仓库建立连接"></a>5. Git 本地仓库与远程仓库建立连接</h2><p><img src="https://cdn.jsdelivr.net/gh/vliamzh/image@main/image/202407131818602.png" alt="origin仓库解释"></p><p><img src="https://cdn.jsdelivr.net/gh/vliamzh/image@main/image/202407131608612.png"></p><h2 id="6-Git解决冲突"><a href="#6-Git解决冲突" class="headerlink" title="6.Git解决冲突"></a>6.Git解决冲突</h2><p><img src="https://cdn.jsdelivr.net/gh/vliamzh/image@main/image/202407131840244.png" alt="git冲突处理"></p><h2 id="7-Git撤销修改"><a href="#7-Git撤销修改" class="headerlink" title="7.Git撤销修改"></a>7.Git撤销修改</h2><p><img src="https://cdn.jsdelivr.net/gh/vliamzh/image@main/image/202407131844369.png" alt="image-20240713184405047"></p><h2 id="8-git-pull"><a href="#8-git-pull" class="headerlink" title="8.git pull"></a>8.git pull</h2><p><img src="https://cdn.jsdelivr.net/gh/vliamzh/image@main/image/202407131847419.png" alt="git pull"></p><h2 id="9-git-rebase"><a href="#9-git-rebase" class="headerlink" title="9.git rebase"></a>9.git rebase</h2><p><img src="https://cdn.jsdelivr.net/gh/vliamzh/image@main/image/202407132323655.png" alt="git rebase"></p><p><img src="https://cdn.jsdelivr.net/gh/vliamzh/image@main/image/202407132325841.png" alt="git rebase原理"></p><p>​&#x3D;&#x3D;上面的例子可抽象为如下实际工作场景：张三从B拉了代码进行开发，目前提交了两次，开发到D了；李四也从B拉出来开发了并且开发完毕，他提交到了M，然后合到主干上了。此时张三想拉下最新代码，于是他在feature分支上执行了git rebase master，即把master分支给rebase过来，由于李四更早开发完并合了主干，如此就相当于张三是基于李四的最新提交M进行的开发了。&#x3D;&#x3D;</p><p><img src="https://cdn.jsdelivr.net/gh/vliamzh/image@main/image/202407132331013.png" alt="实际git提交实例"></p><h2 id="10-git-reset"><a href="#10-git-reset" class="headerlink" title="10.git reset"></a>10.git reset</h2><p>较少用！</p><h2 id="11-git-mv"><a href="#11-git-mv" class="headerlink" title="11.git mv"></a>11.git mv</h2><pre><code class="SHELL">git mv text.txt mydir</code></pre><p>运行上面的 <code>git mv</code> 其实就相当于运行了<code>3</code>条命令：</p><pre><code class="SHELL">$ mv test.txt mydir$ git rm test.txt$ git add mydir</code></pre><h2 id="12-git-rm"><a href="#12-git-rm" class="headerlink" title="12.git rm"></a>12.git rm</h2><p><img src="https://cdn.jsdelivr.net/gh/vliamzh/image@main/image/202407132343200.png" alt="git rm"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;git使用&quot;&gt;&lt;a href=&quot;#git使用&quot; class=&quot;headerlink&quot; title=&quot;git使用&quot;&gt;&lt;/a&gt;git使用&lt;/h1&gt;&lt;p&gt;参考：&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/132573100</summary>
      
    
    
    
    <category term="git" scheme="https://vliamzh.github.io/categories/git/"/>
    
    <category term="教程" scheme="https://vliamzh.github.io/categories/git/%E6%95%99%E7%A8%8B/"/>
    
    
    <category term="git" scheme="https://vliamzh.github.io/tags/git/"/>
    
    <category term="版本控制" scheme="https://vliamzh.github.io/tags/%E7%89%88%E6%9C%AC%E6%8E%A7%E5%88%B6/"/>
    
  </entry>
  
  <entry>
    <title>汽车</title>
    <link href="https://vliamzh.github.io/2024/07/11/%E6%B1%BD%E8%BD%A6/"/>
    <id>https://vliamzh.github.io/2024/07/11/%E6%B1%BD%E8%BD%A6/</id>
    <published>2024-07-11T15:12:10.000Z</published>
    <updated>2024-07-11T15:18:21.950Z</updated>
    
    <content type="html"><![CDATA[<h1 id="from-b站"><a href="#from-b站" class="headerlink" title="from b站"></a>from b站</h1><h1 id="汽车基础"><a href="#汽车基础" class="headerlink" title="汽车基础"></a>汽车基础</h1><ol><li><p>真皮座椅：夏天热、冬天冷，所以有座椅打孔通风、座椅加热，看着豪华，布座最好，所以买的真皮座椅最好带个布套；</p></li><li><p>天窗：晕车可以用，但会导致温室效应，所以非必须；</p></li><li><p>仪表盘：中置好，因为视野可以在减速时不会发生大幅度变化；</p></li><li><p>方向盘：中间固定的，还行。雪铁龙，盾形；方向盘可以调的！！！</p></li><li><p>刹车：右脚控制刹车油门（车评人觉得可以），左脚踩刹车（赛车手觉得可以）；</p></li><li><p>发动机：汽车心脏，为内燃机，外燃机如火车</p></li><li><ol><li>燃料燃烧产生热量，火塞点燃效率不高，压燃原理（烧柴油）</li><li>产生热量推动叶片-燃气轮机，比如飞机、舰艇，重量轻重量轻耗油多-油老虎</li><li>往复式内燃机，高温高压燃气在气缸中推动<strong>活塞</strong>干活，在其中膨胀推动活塞，温度下降，热量推动活塞，活塞推动连杆，<strong>连杆</strong>推动<strong>曲柄</strong>转动，气缸中的燃气不能跑出来，所以有个<strong>气缸盖—曲柄连杆机构！</strong></li><li>发动机需要进气门、排气门，控制二者打开的凸轮和弹簧，进来空气，出去废气！<img src="F:\zhwl\Documents\git_zh\hexo_blog\source_posts\汽车.assets\202407112317220.png" alt="img"></li><li>燃料供应系统，需要空气进入和燃料进入才能燃烧！</li><li>点火系统，对于汽油机来说包括<strong>电源、点火线圈、火花塞</strong>！</li><li>润滑系统，减少发动机的摩擦和磨损；</li><li>燃气燃烧产生的热量会传给发动机，需要及时散热！———冷却系统</li><li>启动系统——启动发动机！</li><li>四冲程理论：发动机的工作分为四个冲程（步骤）</li></ol></li><li><ol><li><ol><li>曲柄转动——连杆带动活塞下行——凸轮压下气门弹簧，推动进气门打开，汽油和空气的混合气体吸入气缸中 《吸气冲程》</li><li>曲柄带动活塞运动到不能继续向下的位置（活塞的下止点）——曲柄带着活塞向上运动，开始压缩，弹簧回弹，进气门关闭，气缸的混合气被压缩，温度不断上升，蒸发变成汽油蒸气，《压缩冲程》高温的燃气膨胀，温度下降，  活塞上升到不能继续上升的位置（上止点），混合气的温度很高，但是依然不能自燃，这时火花塞产生电火花点燃混合气，生成高温高压的燃气，燃气膨胀推动活塞向下，连杆带动曲柄转动，直至活塞到达下止点，<strong>《做功冲程》</strong></li><li>到达下止点，内部燃气温度压力下降，成为废气，排气门被凸轮推开，曲柄带着活塞上行，废气排出 《排气冲程》，之后排气门弹簧回弹，排气门关闭。</li><li>注：<strong>柴油机不一样</strong>，第一气缸内吸进来的气体是空气，第二燃气是由喷油嘴喷进（上止点），气缸的压缩空气温度大于柴油的着火点所以会直接燃烧，</li><li>发动机的<strong>每个冲程，曲柄转动180度</strong>，所以<strong>两圈曲柄（720°）转动</strong>做一次功。</li><li>由于四个冲程只有一个冲程是发动机<strong>做功（活塞带着曲柄转</strong>），其余三个都是<strong>曲柄带着活塞转</strong>，所以效率低，因此会有多缸机（比如四个缸一起，每个），<strong>这里的关键是让每个冲程都由活塞带着曲柄转，因此四缸机可以实现</strong>，不但可以实现动力，还可以推动别的气缸吸气、压缩、排气。<img src="https://cdn.jsdelivr.net/gh/vliamzh/image@main/image/202407112318783.png" alt="img"></li><li>气缸数大于4小于4，装飞轮？-见连杆曲柄结构！</li><li>气缸排排成一列直列（一般最多6个），两列V型（6、8、10、12），还有水平对置发动机（更贵）</li></ol></li></ol></li><li><ol><li>发动机性能参数：</li></ol></li><li><ol><li><ol><li>千瓦&#x3D;0.735X马力</li><li>排量，越大<strong>税越高</strong></li><li><img src="https://cdn.jsdelivr.net/gh/vliamzh/image@main/image/202407112318690.png" alt="img"></li><li>输出转矩，可以通过变速箱变得接近理想</li><li>接近理想输出曲线的是电动机和蒸汽机！</li><li>发动机效率（**30~40%**热量变为多少做的功），柴油车效率高，省油。</li><li>油耗曲线。kw.&#x2F;h，相当于电量的度</li><li><img src="https://cdn.jsdelivr.net/gh/vliamzh/image@main/image/202407112318261.png" alt="img"></li><li><strong>最佳转速下的油耗最低，如果在这个区间觉得车速过快，则是马力大了，说明油耗不适合你，如果觉得车速慢，则是马力小了，如果再给地板油给快车，会让油耗变高。</strong></li><li></li></ol></li></ol></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;from-b站&quot;&gt;&lt;a href=&quot;#from-b站&quot; class=&quot;headerlink&quot; title=&quot;from b站&quot;&gt;&lt;/a&gt;from b站&lt;/h1&gt;&lt;h1 id=&quot;汽车基础&quot;&gt;&lt;a href=&quot;#汽车基础&quot; class=&quot;headerlink&quot; titl</summary>
      
    
    
    
    <category term="汽车" scheme="https://vliamzh.github.io/categories/%E6%B1%BD%E8%BD%A6/"/>
    
    <category term="基础" scheme="https://vliamzh.github.io/categories/%E6%B1%BD%E8%BD%A6/%E5%9F%BA%E7%A1%80/"/>
    
    
    <category term="发动机" scheme="https://vliamzh.github.io/tags/%E5%8F%91%E5%8A%A8%E6%9C%BA/"/>
    
    <category term="汽车" scheme="https://vliamzh.github.io/tags/%E6%B1%BD%E8%BD%A6/"/>
    
  </entry>
  
  <entry>
    <title>SOC核心与线程</title>
    <link href="https://vliamzh.github.io/2024/05/19/SOC%E6%A0%B8%E5%BF%83%E4%B8%8E%E7%BA%BF%E7%A8%8B/"/>
    <id>https://vliamzh.github.io/2024/05/19/SOC%E6%A0%B8%E5%BF%83%E4%B8%8E%E7%BA%BF%E7%A8%8B/</id>
    <published>2024-05-19T05:03:42.000Z</published>
    <updated>2024-05-19T06:35:13.309Z</updated>
    
    <content type="html"><![CDATA[<p>参考：<a href="https://www.eetop.cn/cpu_soc/6951291.html">浅谈多核心CPU和SoC芯片及其工作原理 - 微处理器 - -EETOP-创芯网</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;参考：&lt;a href=&quot;https://www.eetop.cn/cpu_soc/6951291.html&quot;&gt;浅谈多核心CPU和SoC芯片及其工作原理 - 微处理器 - -EETOP-创芯网&lt;/a&gt;&lt;/p&gt;
</summary>
      
    
    
    
    <category term="IC" scheme="https://vliamzh.github.io/categories/IC/"/>
    
    <category term="CPU" scheme="https://vliamzh.github.io/categories/IC/CPU/"/>
    
    
    <category term="cpu" scheme="https://vliamzh.github.io/tags/cpu/"/>
    
    <category term="soc" scheme="https://vliamzh.github.io/tags/soc/"/>
    
  </entry>
  
  <entry>
    <title>vim自用</title>
    <link href="https://vliamzh.github.io/2024/05/17/vim%E8%87%AA%E7%94%A8/"/>
    <id>https://vliamzh.github.io/2024/05/17/vim%E8%87%AA%E7%94%A8/</id>
    <published>2024-05-17T05:28:53.000Z</published>
    <updated>2024-07-13T15:53:23.445Z</updated>
    
    <content type="html"><![CDATA[<p>[toc]</p><h1 id="一、帮助文件"><a href="#一、帮助文件" class="headerlink" title="一、帮助文件"></a>一、帮助文件</h1><h2 id="1-帮助文件的使用"><a href="#1-帮助文件的使用" class="headerlink" title="1. 帮助文件的使用"></a>1. 帮助文件的使用</h2><p>帮助文件方便随时查阅</p><pre><code class="vim">在命令行输入:help或在右边分栏显示:vert bo h number (:vertical boright help number) vert表示将后面的命令结果垂直分割显示 boright表示窗口在右边更多:help x 得到x命令的帮助:help CTRL-A 得到命令模式下ctrl_a的帮助:help i_CTRL_H 得到插入模式下ctrl_h的帮助:h i_&lt;UP&gt; :h E37 得到某一个错误的帮助</code></pre><h1 id="二、常用"><a href="#二、常用" class="headerlink" title="二、常用"></a>二、常用</h1><h2 id="1-插入与替换"><a href="#1-插入与替换" class="headerlink" title="1. 插入与替换"></a>1. 插入与替换</h2><pre><code>i 光标前插入I 光标置于当前行的第一个非空白字符进入插入模式a 光标后插入A 光标置于行尾进入插入模式o 下面另起一行，并直接变成插入模式O 大写，在上面另起一行，并变成插入模式cw 删除当前word重新编写C/c$ 删除到行尾重新编写 直接用C可以代替S/cc 删除整行重新编写，保留缩进 直接用S可以代替s/cl 修改一个字符cis 修改整个句子，不包括后面空格，as包括r 替换，r&lt;ENTER&gt; 直接隔断换行R 直接进入替换模式，输入内容直接替换直到ESC</code></pre><p>PS：命令行计数</p><pre><code>3a! 可以直接插入3个！3x 直接删除3个字符3k 直接上移3个位置3w 移动3个word1$ 移动到当前行的行尾2$ 移动到下一行的行尾3fa 向右搜索第三个a出现的位置33G 跳转到33行3# 向上搜索单词出现的第三次位置</code></pre><h2 id="2-删除与复制、粘贴"><a href="#2-删除与复制、粘贴" class="headerlink" title="2. 删除与复制、粘贴"></a>2. 删除与复制、粘贴</h2><pre><code>x 光标下的字符删除，或者dlX 删除光标左边的字符，dhdd 删除一行dw 删除光标所在处的worddaw 删除光标所在的整个word！！！D/d$ 一直删除到末尾，直接大写DJ 两行合并为一行u 撤销U 大写，撤销对一行的全部操作，如一行某个单词被x，通过U可以直接恢复ctrl-r 重做：反转撤销p 会把x和d删除内容重新put回来放到光标后，P则放到光标前y 文本复制到寄存器找那个，yanking，yw复制一个word会把word后面的空白字符也复制，用ye可以避免yy 复制整行y$ 复制一直到行尾的内容&quot;*yy 把一行内容复制到剪切板！！！&quot;*p 从剪切板粘贴</code></pre><h2 id="3-移动与跳转"><a href="#3-移动与跳转" class="headerlink" title="3. 移动与跳转"></a>3. 移动与跳转</h2><pre><code class="‘">% 跳转到匹配符号，比如（）[] &#123;&#125; 直接跳转到匹配嵌套的符号，常用！！！！！50% 光标定位到文件中间，90%则是接近尾巴处H/M/L 定位到文件HOME/MIDDLE/LAST位置w 以1个word为单位向前移动，移动到下一个单词的首字符b 同上，但移动到上一个单词的首字符e 以1个word为单位向前移动，但是移动到下一个单词的末尾字符，end of wordge 同上，但是移动到上一个单词的末尾字符W/B E/gE 上面字母大写，表示移动的word内部含有- _ (等符号，即这些符号与word被这些操作认为是新的WORD$ 类似键盘的end，移动到行尾0 数字，类似键盘的home，移动到行首，字面意思，不区分空白与非空白字符，直接行首顶格^ 移动到当前行的第一个非空白的字符上fy 命令模式下向右直接跳转到第一个y的位置，类似fh则跳转到字符h的位置，F则向左搜索，f的意思是findty 同上，但是不是跳转到y的位置，而是跳转到y前一个字符为止，T则向左， t的意思是to；与， 可以重复上面操作 注：这两个可能会用于其他用途CTRL-G 显示当前行号CTRL-U 向上滚动半个屏幕，CTRL-D则是向下，CTRL-E滚动一行，CTRL-Y与其相反CRRL-F 滚动一个屏，，CTRL-B与其方向相反zz 定位当前屏幕的正中央，最好不用，因为ZZ是保存与退出，容易误操作zb 当前行置于屏幕最低部zt 当前行置于屏幕最顶部</code></pre><h2 id="4-搜索"><a href="#4-搜索" class="headerlink" title="4. 搜索"></a>4. 搜索</h2><pre><code>/ 搜索字符，比如/zh 搜索字符zh .*[]%^?~$ 需要前面加上转义字符\？搜索字符，方向与/相反n 跳转到下一个搜索字符，N方向相反:set ignorecase 忽略大小写 搜索* 直接光标放到单词位置，按下*即可搜索，#也可以，只不过方向相反/the\&gt; 只会搜索the结尾，而不会搜索there这种，\表示单词结束/\&lt;the\&gt; 只会搜索单词theg* 会搜索到包含单词的部分，比如搜索the，则会高亮到there这种，*和#都是完整匹配一个单词的！！！:set hlserach高亮设置:set noh 取消高亮正则表达式^include 只会搜索一行开头的includewas$ 只会搜索结尾的was/^the$ 只会搜索仅有the的字符. 匹配任何字符，如c.m会找到类似cam,com,cem等字符特殊字符要加\，比如搜索“ter.”则用ter\.`` 在两点来回跳转，先用G，在``回到起始位置，推荐ctrl-o,ctrl-i或ctrl-t,或鼠标右键</code></pre><h2 id="5-标记"><a href="#5-标记" class="headerlink" title="5. 标记"></a>5. 标记</h2><pre><code>ma 当前光标下的位置名标记为a，有26字母可选mb...mz 使用`a，跳到标签a，`z调到标签z，然后``在二者来回跳转！！！使用单引号’a，跳到标签a所在行首:marks 查看标记点:jumps 查看跳转过的位置列表</code></pre><h2 id="6-特殊字符"><a href="#6-特殊字符" class="headerlink" title="6. 特殊字符"></a>6. 特殊字符</h2><pre><code>. 重复操作命令</code></pre><h2 id="7-块操作"><a href="#7-块操作" class="headerlink" title="7. 块操作"></a>7. 块操作</h2><pre><code>v 选择范围V 大写，选择一行ctrl-v 选择一个矩形块，然后按hjkl选择，如果想回到起始位置扩大起点可以按o，表示other end另一头！！！</code></pre><h2 id="8-大小写"><a href="#8-大小写" class="headerlink" title="8. 大小写"></a>8. 大小写</h2><pre><code>~ 可以配合块操作一键大写或小写内容</code></pre><h1 id="三、键位图"><a href="#三、键位图" class="headerlink" title="三、键位图"></a>三、键位图</h1><p>来源：<a href="https://www.runoob.com/w3cnote/all-vim-cheatsheat.html">菜鸟教程</a></p><p><img src="https://cdn.jsdelivr.net/gh/vliamzh/image@main/image/202407132347856.png" alt="入门"></p><p><img src="https://cdn.jsdelivr.net/gh/vliamzh/image@main/image/202407132348153.png" alt="进阶"></p><p><img src="https://cdn.jsdelivr.net/gh/vliamzh/image@main/image/202407132349869.png" alt="增强版"></p><p><img src="https://cdn.jsdelivr.net/gh/vliamzh/image@main/image/202407132349207.png" alt="文字版"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;[toc]&lt;/p&gt;
&lt;h1 id=&quot;一、帮助文件&quot;&gt;&lt;a href=&quot;#一、帮助文件&quot; class=&quot;headerlink&quot; title=&quot;一、帮助文件&quot;&gt;&lt;/a&gt;一、帮助文件&lt;/h1&gt;&lt;h2 id=&quot;1-帮助文件的使用&quot;&gt;&lt;a href=&quot;#1-帮助文件的使用&quot; clas</summary>
      
    
    
    
    <category term="Linux" scheme="https://vliamzh.github.io/categories/Linux/"/>
    
    <category term="vim" scheme="https://vliamzh.github.io/categories/Linux/vim/"/>
    
    
    <category term="vim" scheme="https://vliamzh.github.io/tags/vim/"/>
    
    <category term="教程" scheme="https://vliamzh.github.io/tags/%E6%95%99%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>一些网站</title>
    <link href="https://vliamzh.github.io/2024/05/14/%E4%B8%80%E4%BA%9B%E7%BD%91%E7%AB%99/"/>
    <id>https://vliamzh.github.io/2024/05/14/%E4%B8%80%E4%BA%9B%E7%BD%91%E7%AB%99/</id>
    <published>2024-05-14T05:35:35.000Z</published>
    <updated>2024-08-04T07:21:40.616Z</updated>
    
    <content type="html"><![CDATA[<p>持续更新……</p><h1 id="技术类"><a href="#技术类" class="headerlink" title="技术类"></a>技术类</h1><p><a href="https://csdiy.wiki/">CS自学指南</a> 绝对满分！包括下面的评论区也会有很多干货。</p><p>里面还有一些实用工具箱分类：<a href="https://csdiy.wiki/%E5%BF%85%E5%AD%A6%E5%B7%A5%E5%85%B7/tools/">实用工具箱</a></p><h1 id="论坛类"><a href="#论坛类" class="headerlink" title="论坛类"></a>论坛类</h1><ul><li>[IT之家](<a href="https://www.ithome.com/">IT之家 (ithome.com)</a>)</li><li><a href="https://www.tmtpost.com/">钛媒体</a></li><li>[虎嗅](<a href="https://www.huxiu.com/">虎嗅网 (huxiu.com)</a>)</li><li>[ZAKER](<a href="https://www.myzaker.com/">ZAKER新闻 (myzaker.com)</a>)</li><li>[果壳](<a href="https://www.guokr.com/">果壳 科技有意思 (guokr.com)</a>)</li><li>今日热榜</li><li>虎扑</li><li>s1</li><li>nga</li><li><a href="https://www.v2ex.com/">V2EX</a></li><li>[水木](<a href="https://www.newsmth.net/">水木社区-源于清华的高知社群 (newsmth.net)</a>)</li><li>[硬件评测：chiphell](<a href="https://www.chiphell.com/">首页 - Chiphell - 分享与交流用户体验</a>)</li><li>[虫部落](<a href="https://www.chongbuluo.com/">虫部落 - 让搜索更简单 (chongbuluo.com)</a>)</li><li>[小木虫](<a href="https://muchong.com/bbs/">小木虫论坛-学术科研互动平台 (muchong.com)</a>)</li><li>吾爱</li><li>豆瓣</li><li>[通信人家园](<a href="https://www.txrjy.com/forum.php">通信人家园 论坛|通信社区 - Powered by C114 (txrjy.com)</a>****)</li><li>[姑苏网](<a href="https://www.gusuwang.com/">姑苏网 - 苏州综合社区门户网站|苏州论坛|姑苏论坛|苏州门户网|gusuwang.com</a>)  </li><li>[开源中国](<a href="https://www.oschina.net/">OSCHINA - 中文开源技术交流社区</a>)  </li><li>[考公：论坛QZZN](<a href="https://bbs.qzzn.com/">QZZN论坛 公务员考试论坛 公务员论坛 公考论坛 Q坛 -</a>)  </li><li>[留学：一亩三分地](<a href="https://www.1point3acres.com/bbs/">一亩三分地-美国加拿大留学申请|工作就业|英语考试|学习生活信噪比最高的网站 (1point3acres.com)</a>)  </li><li>宽带山（buhao）</li><li>知乎</li><li><a href="https://www.quora.com/">国外版知乎</a></li><li><a href="https://www.reddit.com/">reddit</a></li><li></li></ul><h1 id="娱乐类"><a href="#娱乐类" class="headerlink" title="娱乐类"></a>娱乐类</h1><p>- </p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;持续更新……&lt;/p&gt;
&lt;h1 id=&quot;技术类&quot;&gt;&lt;a href=&quot;#技术类&quot; class=&quot;headerlink&quot; title=&quot;技术类&quot;&gt;&lt;/a&gt;技术类&lt;/h1&gt;&lt;p&gt;&lt;a href=&quot;https://csdiy.wiki/&quot;&gt;CS自学指南&lt;/a&gt; 绝对满分！包括下面的评</summary>
      
    
    
    
    <category term="收藏夹" scheme="https://vliamzh.github.io/categories/%E6%94%B6%E8%97%8F%E5%A4%B9/"/>
    
    <category term="网站" scheme="https://vliamzh.github.io/categories/%E6%94%B6%E8%97%8F%E5%A4%B9/%E7%BD%91%E7%AB%99/"/>
    
    
    <category term="导航" scheme="https://vliamzh.github.io/tags/%E5%AF%BC%E8%88%AA/"/>
    
    <category term="网站" scheme="https://vliamzh.github.io/tags/%E7%BD%91%E7%AB%99/"/>
    
  </entry>
  
  <entry>
    <title>markdown语法</title>
    <link href="https://vliamzh.github.io/2024/05/13/markdown%E8%AF%AD%E6%B3%95/"/>
    <id>https://vliamzh.github.io/2024/05/13/markdown%E8%AF%AD%E6%B3%95/</id>
    <published>2024-05-13T14:00:18.000Z</published>
    <updated>2024-07-13T08:29:15.892Z</updated>
    
    <content type="html"><![CDATA[<p>参考：</p><p><a href="https://wallleap.cn/2020/03/29/markdown/">Markdown语法大全 | 个人学习心得体会 (wallleap.cn)</a></p><p><a href="https://blog.csdn.net/xdnxl/article/details/129518943?utm_medium=distribute.pc_relevant.none-task-blog-2~default~baidujs_baidulandingword~default-0-129518943-blog-82183140.235%5Ev43%5Epc_blog_bottom_relevance_base3&spm=1001.2101.3001.4242.1&utm_relevant_index=1#1">markdown语法大总结【全网汇总，从0到深大全版】</a></p><p><a href="https://blog.csdn.net/southink/article/details/119297952">Markdown 入门及语法详细指南 ★</a></p><p><a href="%5BTypora%E5%9F%BA%E7%A1%80%E8%AE%BE%E7%BD%AE%E3%80%81MarkDown%E8%AF%AD%E6%B3%95_markdown%E5%BC%82%E6%88%96%E7%AC%A6%E5%8F%B7-CSDN%E5%8D%9A%E5%AE%A2%5D(https://blog.csdn.net/zzh45828/article/details/105883083)">Typora基础设置、MarkDown语法</a></p><p><a href="%5BTypora%E5%B8%B8%E7%94%A8%E5%A5%BD%E7%9C%8B%E4%B8%BB%E9%A2%98%E6%8E%A8%E8%8D%90!!!_typora%E4%B8%BB%E9%A2%98-CSDN%E5%8D%9A%E5%AE%A2%5D(https://blog.csdn.net/weixin_52023681/article/details/120251523)">Typora常用好看主题推荐!!!</a></p><p><a href="https://www.cnblogs.com/tsingke/p/10901654.html">markdown图片并排显示</a></p><p>PS: typera关于任务列表不起作用的问题：需要在原本语法基础上即一个减号+空格+中括号[]+空格，然后中括号内部也要加空格或者x</p><hr><p>[toc]</p><hr><h2 id="一、概述"><a href="#一、概述" class="headerlink" title="一、概述"></a>一、概述</h2><h3 id="1-1-设计理念"><a href="#1-1-设计理念" class="headerlink" title="1.1 设计理念"></a>1.1 设计理念</h3><ul><li>Markdown 易于阅读，方便创作web文档，利于各平台无缝分发。</li><li>Markdown 语法灵感最大的来源还是纯文本 email 的格式，完全由标点符号标签组成的纯文本。</li><li>Markdown 文件应该以纯文本形式原样发布，不应该包含标记标签和格式化指令。</li></ul><h3 id="1-2-内联-HTML-语法"><a href="#1-2-内联-HTML-语法" class="headerlink" title="1.2 内联 HTML 语法"></a>1.2 内联 HTML 语法</h3><ul><li>HTML 是一种发布格式，Markdown 是一种创作格式。</li><li>Markdown语法集合比较小，只是HTML标签的一小部分。</li><li>对于 Markdown 中未包含的标签, 可以直接使用 HTML标签，例如用 HTML 标签替代 Markdown 的链接语法。</li></ul><h3 id="1-3-特殊字符自动转义"><a href="#1-3-特殊字符自动转义" class="headerlink" title="1.3 特殊字符自动转义"></a>1.3 特殊字符自动转义</h3><p>在 HTML 中, 有两个字符需要特殊对待: &lt; 和 &amp;，左尖括号用于起始标签。果你想将它们用作字面量, 你必须将它们转义为字符实体, 例如<code>&lt;</code> 和 <code>&amp;</code>。</p><h2 id="二、行内语法讲解"><a href="#二、行内语法讲解" class="headerlink" title="二、行内语法讲解"></a>二、行内语法讲解</h2><h3 id="2-1-注释的表述"><a href="#2-1-注释的表述" class="headerlink" title="2.1 注释的表述"></a>2.1 注释的表述</h3><ul><li><p>代码法</p><pre><code class="markdown">&lt;div style=&#39;display: none&#39;&gt;哈哈我是注释，不会在浏览器中显示。&lt;/div&gt;</code></pre></li><li><p>html注释</p></li></ul><p>既然支持html语法，那也支持html注释，快捷键 comment + &#x2F;。</p><pre><code class="markdown">&lt;!--哈哈我是注释，不会在浏览器中显示。--&gt;&lt;!--哈哈我是多段注释，不会在浏览器中显示。    --&gt;</code></pre><ul><li>hack方法</li></ul><p>hack方法就是利用markdown的解析原理来实现注释的。<br>一般有的markdown解析器不支持上面的注释方法，这个时候就可以用hack方法。<br>hack方法比上面2种方法稳定得多，但是语义化太差。</p><pre><code class="markdown">[//]: # (哈哈我是最强注释，不会在浏览器中显示。)[^_^]: # (哈哈我是最萌注释，不会在浏览器中显示。)[//]: &lt;&gt; (哈哈我是注释，不会在浏览器中显示。)[comment]: &lt;&gt; (哈哈我是注释，不会在浏览器中显示。)</code></pre><h3 id="2-2-分级标题、任务列表"><a href="#2-2-分级标题、任务列表" class="headerlink" title="2.2 分级标题、任务列表"></a>2.2 分级标题、任务列表</h3><ul><li><p>分级标题</p><pre><code># 一级标题## 二级标题### 三级标题#### 四级标题##### 五级标题###### 六级标题  &lt;!--最多6级标题--&gt;</code></pre><p>由于用了标记编辑器会把所有标题写到目录大纲中，在这里写的演示标题也会列进去，所以就不演示了。同学们自己在编辑器中观察，很简单，一级标题字号最大，依级递减。</p></li><li><p>任务列表<br>Markdown 语法：<br>`&#96;&#96;后面接语法markdown</p><pre><code class="markdown">效果如下：</code></pre></li><li><p>任务一 未做任务 <code>- + 空格 + [ ]</code></p></li><li><p>任务二 已做任务 <code>- + 空格 + [x]</code></p></li><li><p><input disabled="" type="checkbox"> 任务一 未做任务 - + 空格 + [ ]</p></li><li><p><input checked="" disabled="" type="checkbox"> 任务二 已做任务 - + 空格 + [x]</p></li><li><p><input disabled="" type="checkbox"> </p></li><li><p><input checked="" disabled="" type="checkbox"> </p></li></ul><h3 id="2-3-缩进、换行、空行、对齐方式"><a href="#2-3-缩进、换行、空行、对齐方式" class="headerlink" title="2.3 缩进、换行、空行、对齐方式"></a>2.3 缩进、换行、空行、对齐方式</h3><ul><li><p>首行缩进<br>不同特殊占位符所占空白是不一样大的。</p><pre><code class="markdown">【1】 &amp;emsp;或&amp;#8195; //全角【2】 &amp;ensp;或&amp;#8194; //半角【3】 &amp;nbsp;或&amp;#160;  //半角之半角</code></pre></li><li><p>换行<br>由于markdown编辑器的不同,可能在一行字后面，直接换行回车，也能实现换行，但是在Visual Studio Code上，想要换行<strong>必须得在一行字后面空两个格子才行</strong>。</p></li></ul><p>空行<br>在编辑的时候有多少个空行(只要这一行只有回车或者space没有其他的字符就算空行)，<strong>在渲染之后，只隔着一行</strong>。</p><ul><li><p>对齐方式</p><p>代码：</p><pre><code class="markdown">&lt;center&gt;行中心对齐&lt;/center&gt;&lt;p align=&quot;left&quot;&gt;行左对齐&lt;/p&gt;&lt;p align=&quot;right&quot;&gt;行右对齐&lt;/p&gt;</code></pre><p>显示效果：</p></li></ul><p>行中心对齐</p><p>行左对齐</p><p>行右对齐</p><h3 id="2-4-斜体、粗体、删除线、下划线、背景高亮"><a href="#2-4-斜体、粗体、删除线、下划线、背景高亮" class="headerlink" title="2.4 斜体、粗体、删除线、下划线、背景高亮"></a>2.4 斜体、粗体、删除线、下划线、背景高亮</h3><p>代码：</p><pre><code class="markdown">*斜体*或_斜体_**粗体*****加粗斜体***~~删除线~~++下划线++==背景高亮==     有一些不支持</code></pre><p>显示效果：<br>  <em>斜体</em>  <strong>粗体</strong>  *<strong>加粗斜体*</strong>  <del>删除线</del>  ++删除线++   &#x3D;&#x3D;背景高亮&#x3D;&#x3D;</p><h3 id="2-5-超链接、页内链接、自动链接、注脚"><a href="#2-5-超链接、页内链接、自动链接、注脚" class="headerlink" title="2.5 超链接、页内链接、自动链接、注脚"></a>2.5 超链接、页内链接、自动链接、注脚</h3><ul><li>行内式<br>语法说明：</li></ul><p>[]里写链接文字，()里写链接地址, ()中的””中可以为链接指定title属性，title属性可加可不加。title属性的效果是鼠标悬停在链接上会出现指定的 title文字，链接地址与title前有一个空格。</p><p>代码：</p><pre><code class="markdown">欢迎阅读 [择势勤](https://www.jianshu.com/u/16d77399d3a7 &quot;择势勤&quot;)</code></pre><p>显示效果：</p><p>欢迎阅读 <a href="https://www.jianshu.com/u/16d77399d3a7">择势勤</a></p><ul><li>参考式<br>参考式超链接一般用在学术论文上面，或者另一种情况，如果某一个链接在文章中多处使用，那么使用引用 的方式创建链接将非常好，它可以让你对链接进行统一的管理。</li></ul><p>语法说明：<br>参考式链接分为两部分，文中的写法 [链接文字][链接标记]，在文本的任意位置添加[链接标记]:链接地址。</p><p>如果链接文字本身可以做为链接标记，你也可以写成[链接文字][]<br>[链接文字]：链接地址的形式，见代码的最后一行。</p><p>代码：</p><pre><code>我经常去的几个网站[Google][1]、[Leanote][2]。[1]:http://www.google.com [2]:http://www.leanote.com</code></pre><p>显示效果：<br>我经常去的几个网站<a href="http://www.google.com/">Google</a>、<a href="http://www.leanote.com/">Leanote</a>。</p><ul><li>注脚<br>语法说明：</li></ul><p>在需要添加注脚的文字后加上脚注名字[^注脚名字],称为加注。 然后在文本的任意位置(一般在最后)添加脚注，脚注前必须有对应的脚注名字。</p><p>注意：经测试注脚与注脚之间必须空一行，不然会失效。成功后会发现，即使你没有把注脚写在文末，经Markdown转换后，也会自动归类到文章的最后。</p><p>代码：</p><pre><code class="markdown">使用 Markdown[^1]可以效率的书写文档, 直接转换成 HTML[^2]。[^1]:Markdown是一种纯文本标记语言[^2]:HyperText Markup Language 超文本标记语言</code></pre><p>显示效果：</p><p>使用 Markdown<a href="https://wallleap.cn/2020/03/29/markdown/Markdown%E6%98%AF%E4%B8%80%E7%A7%8D%E7%BA%AF%E6%96%87%E6%9C%AC%E6%A0%87%E8%AE%B0%E8%AF%AD%E8%A8%80">^1</a>可以效率的书写文档, 直接转换成 HTML[^2]。</p><p>[^2]: HyperText Markup Language 超文本标记语言</p><p>注：脚注自动被搬运到最后面，请到文章末尾查看，脚注后方的链接可以直接跳转回到加注的地方。</p><ul><li>锚点（页内超链接）<br>网页中，锚点其实就是页内超链接，也就是链接本文档内部的某些元素，实现当前页面中的跳转。比如我这里写下一个锚点，点击回到目录，就能跳转到目录。 在目录中点击这一节，就能跳过来。还有下一节的注脚。这些根本上都是用锚点来实现的，只支持在标题后插入锚点，其它地方无效。</li></ul><p>代码：</p><pre><code class="markdown">## 0. 目录&#123;#index&#125;</code></pre><p>显示效果：</p><p>跳转到目录</p><ul><li>自动链接<br>语法说明：<br>Markdown 支持以比较简短的自动链接形式来处理网址和电子邮件信箱，只要是用&lt;&gt;包起来， Markdown 就会自动把它转成链接。一般网址的链接文字就和链接地址一样，例如：</li></ul><p>代码：</p><pre><code>&amp;lt;http://example.com/&amp;gt; &amp;emsp;&amp;emsp; &amp;lt;address@example.com&amp;gt;</code></pre><p>显示效果：</p><p><a href="http://example.com/">http://example.com/</a>   <br>&lt;<a href="mailto:address@example.com">address@example.com</a>&gt;</p><h3 id="2-6-无序列表、有序列表、定义型列表"><a href="#2-6-无序列表、有序列表、定义型列表" class="headerlink" title="2.6 无序列表、有序列表、定义型列表"></a>2.6 无序列表、有序列表、定义型列表</h3><p>&#x3D; 无序列表</p><p>使用 *，+，- 表示无序列表。</p><p>代码：</p><pre><code class="markdown">* 无序列表项 一+ 无序列表项 二- 无序列表项 三</code></pre><p>显示效果：</p><ul><li><p>无序列表项 一</p></li><li><p>无序列表项 二</p></li><li><p>无序列表项 三</p></li></ul><p>&#x3D; 有序列表</p><p>有序列表则使用<strong>数字接着一个英文句点</strong>。数字不需要连续123，如135都行<br>代码：</p><pre><code class="markdown">1. 有序列表项 一2. 有序列表项 二3. 有序列表项 三</code></pre><p>显示效果：</p><ol><li>有序列表项 一</li><li>有序列表项 二</li><li>有序列表项 三</li></ol><p>&#x3D; 定义型列表表</p><p>语法说明：</p><p>定义型列表由名词和解释组成。一行写上定义，紧跟一行写上解释。解释的写法:紧跟一个缩进(Tab)</p><p>代码</p><pre><code class="markdown">Markdown:   轻量级文本标记语言（左侧有一个可见的冒号和四个不可见的空格）</code></pre><p>显示效果：</p><ul><li><p>Markdown</p><p>轻量级文本标记语言，可以转换成html，pdf等格式</p></li></ul><h3 id="2-7-插入图像"><a href="#2-7-插入图像" class="headerlink" title="2.7 插入图像"></a>2.7 插入图像</h3><p>语法中<code>图片Alt</code>的意思是如果图片因为某些原因不能显示，就用定义的<code>图片Alt</code>文字来代替图片。 <code>图片Title</code>则和链接中的Title一样，表示鼠标悬停与图片上时出现的文字。 Alt 和 Title 都不是必须的，可以省略，但建议写上。</p><p>Markdown 语法：</p><pre><code class="markdown">&lt;center&gt;  &lt;!--开始居中对齐--&gt;![GitHub set up](http://zh.mweb.im/asset/img/set-up-git.gif &quot;图片Title&quot;)格式: ![图片Alt](图片地址 &quot;图片Title&quot;)&lt;/center&gt; &lt;!--结束居中对齐--&gt;</code></pre><p>效果如下：</p><p><img src="https://cdn.jsdelivr.net/gh/vliamzh/image@main/image/202405132219098.gif" alt="GitHub set up" title="图片Title"></p><h3 id="2-8-多级引用"><a href="#2-8-多级引用" class="headerlink" title="2.8 多级引用"></a>2.8 多级引用</h3><p>语法说明：</p><p>引用需要在被引用的文本前加上<code>&gt;符号和空格</code>，允许多层嵌套，也允许你偷懒只在整个段落的第一行最前面加上<code>&gt;</code>。</p><p>代码：</p><pre><code class="markdown">&gt;&gt;&gt; 请问 Markdwon 怎么用？ - 小白&gt;&gt; 自己看教程！ - 愤青&gt; 教程在哪？ - 小白</code></pre><p>  显示效果：</p><blockquote><blockquote><blockquote><p>请问 Markdwon 怎么用？ - 小白<br>自己看教程！ - 愤青<br>教程在哪？ - 小白</p></blockquote></blockquote></blockquote><h3 id="2-9-转义字符、字体、字号、颜色"><a href="#2-9-转义字符、字体、字号、颜色" class="headerlink" title="2.9 转义字符、字体、字号、颜色"></a>2.9 转义字符、字体、字号、颜色</h3><ul><li>转义字符</li></ul><p>Markdown中的转义字符为\，转义的有：</p><pre><code class="markdown">\\ 反斜杠\` 反引号 \* 星号 \_ 下划线 \&#123;\&#125; 大括号 \[\] 中括号 \(\) 小括号  \# 井号 \+ 加号 \- 减号 \. 英文句号 \! 感叹号</code></pre><ul><li><p>字体、字号、颜色</p><p>代码：</p><pre><code class="html">&lt;font face=&quot;黑体&quot;&gt;我是黑体字&lt;/font&gt;&lt;font face=&quot;微软雅黑&quot;&gt;我是微软雅黑&lt;/font&gt;&lt;font face=&quot;STCAIYUN&quot;&gt;我是华文彩云&lt;/font&gt;&lt;font color=#0099ff size=12 face=&quot;黑体&quot;&gt;黑体&lt;/font&gt;&lt;font color=gray size=5&gt;gray&lt;/font&gt;&lt;font color=#00ffff size=3&gt;null&lt;/font&gt;</code></pre><p>显示效果：</p><p><font face="黑体">我是黑体字</font><br><font face="微软雅黑">我是微软雅黑</font><br><font face="STCAIYUN">我是华文彩云</font><br><font color=#0099ff size=12 face="黑体">黑体</font><br><font color=gray size=5>gray</font><br><font color=#00ffff size=3>null</font></p></li></ul><h2 id="三、块语法讲解"><a href="#三、块语法讲解" class="headerlink" title="三、块语法讲解"></a>三、块语法讲解</h2><h3 id="3-1-内容目录"><a href="#3-1-内容目录" class="headerlink" title="3.1 内容目录"></a>3.1 内容目录</h3><p>在段落中填写[ t o c ]</p><p>以显示全文内容的目录结构。</p><pre><code class="markdown">[toc]</code></pre><p>效果参见最上方的目录。</p><h3 id="3-2-代码块"><a href="#3-2-代码块" class="headerlink" title="3.2 代码块"></a>3.2 代码块</h3><p>对于程序员来说这个功能是必不可少的，插入程序代码的方式有两种，一种是利用缩进(Tab), 另一种是<strong>利用&#96;符号</strong>（一般在ESC键下方）包裹代码。</p><ul><li><p>行内式</p><p>代码：</p><pre><code class="c">C语言里的函数 `scanf()` 怎么使用？ PS：只用了一对``</code></pre><p>显示效果：</p><p>​C语言里的函数<code>scanf()</code>怎么使用？</p></li><li><p><strong>缩进式多行代码</strong><br>缩进 4 个空格或是 1 个制表符</p></li></ul><p>一个代码区块会一直持续到没有缩进的那一行（或是文件结尾）。</p><p>代码：   </p><pre><code class="C">#include &amp;lt;stdio.h&amp;gt;int main(void)&#123;    printf(&amp;#34;Hello world\n&amp;#34;);&#125;</code></pre><ul><li><p>用<u>六个 &#96;</u>包裹多行代码</p><p>代码：</p><pre><code class="markdown">、、、include &lt;stdio.h&gt;int main(void)&#123;printf(&quot;Hello world\n&quot;);&#125;、、、</code></pre><p>显示效果：</p><pre><code class="c++">include &lt;stdio.h&gt;int main(void)&#123;printf(&quot;Hello world\n&quot;);&#125;</code></pre></li></ul><h3 id="3-3-流程图"><a href="#3-3-流程图" class="headerlink" title="3.3 流程图"></a>3.3 流程图</h3><p>编辑自有道云笔记，代码：</p><pre><code class="markdown">​```graph LRA--&gt;B​```​```sequenceDiagramA-&gt;&gt;B: How are you?B-&gt;&gt;A: Great!​```</code></pre><p>显示效果：</p><pre><code class="markdown">graph LRA--&gt;BsequenceDiagramA-&gt;&gt;B: How are you?B-&gt;&gt;A: Great!</code></pre><h3 id="3-4-表格"><a href="#3-4-表格" class="headerlink" title="3.4 表格"></a>3.4 表格</h3><p>语法说明：</p><p>不管是哪种方式，<strong>第一行为表头</strong>，<strong>第二行分隔表头和主体部分</strong>，<strong>第三行开始每一行为一个表格行</strong>。<br>列于列之间用<code>管道符|</code>隔开。原生方式的表格每一行的<code>两边也要有管道符</code>。<br>第二行还可以为不同的列指定对齐方向。默认为左对齐，在-右边加上:就右对齐。<br><code>-</code> 左对齐，<code>:-:</code>中心对齐，<code>-:</code>右对齐</p><p>表格代码：</p><pre><code class="markdown">|学号|姓名|序号||-|-|-||小明明|男|5||小红|女|79||小陆|男|192|</code></pre><p>原生方式写表格，显示效果：</p><table><thead><tr><th align="center">学号</th><th align="center">姓名</th><th align="center">序号</th></tr></thead><tbody><tr><td align="center">小明明</td><td align="center">男</td><td align="center">5</td></tr><tr><td align="center">小红</td><td align="center">女</td><td align="center">79</td></tr><tr><td align="center">小陆</td><td align="center">男</td><td align="center">192</td></tr></tbody></table><table><thead><tr><th align="center">第一行头</th><th align="center">第一行中</th><th align="center">第一行尾</th></tr></thead><tbody><tr><td align="center">A</td><td align="center">B</td><td align="center">C</td></tr></tbody></table><hr><h3 id="3-5-LaTeX-公式"><a href="#3-5-LaTeX-公式" class="headerlink" title="3.5 LaTeX 公式"></a>3.5 LaTeX 公式</h3><ul><li><p>表示行内公式</p><p>代码：</p><pre><code class="markdown">质能守恒方程可以用一个很简洁的方程式 `$E = m c^2 $`来表达。</code></pre><p>显示效果：</p></li></ul><p>质能守恒方程可以用一个很简洁的方程式 <code>$E = m c^2 $</code>来表达。</p><ul><li>表示整行公式</li></ul><p>大部分的浏览器支持的</p><pre><code class="markdown">$$ 公式 $$</code></pre><p>有道云笔记 使用格式，</p><pre><code class="markdown">​```mathE = mc^2​```</code></pre><p>块级公式：</p><pre><code class="markdown">​```mathx = \dfrac&#123;-b \pm \sqrt&#123;b^2 - 4ac&#125;&#125;&#123;2a&#125; ​```​```math[\frac&#123;1&#125;&#123;\Bigl(\sqrt&#123;\phi \sqrt&#123;5&#125;&#125;-\phi\Bigr) e^&#123;\frac25 \pi&#125;&#125; =1+\frac&#123;e^&#123;-2\pi&#125;&#125; &#123;1+\frac&#123;e^&#123;-4\pi&#125;&#125; &#123;1+\frac&#123;e^&#123;-6\pi&#125;&#125;&#123;1+\frac&#123;e^&#123;-8\pi&#125;&#125; &#123;1+\ldots&#125; &#125; &#125; &#125;]​```</code></pre><p>显示效果：</p><pre><code class="markdown">x = \dfrac&#123;-b \pm \sqrt&#123;b^2 - 4ac&#125;&#125;&#123;2a&#125; 1[\frac&#123;1&#125;&#123;\Bigl(\sqrt&#123;\phi \sqrt&#123;5&#125;&#125;-\phi\Bigr) e^&#123;\frac25 \pi&#125;&#125; =1+\frac&#123;e^&#123;-2\pi&#125;&#125; &#123;1+\frac&#123;e^&#123;-4\pi&#125;&#125; &#123;1+\frac&#123;e^&#123;-6\pi&#125;&#125;&#123;1+\frac&#123;e^&#123;-8\pi&#125;&#125; &#123;1+\ldots&#125; &#125; &#125; &#125;]</code></pre><p>访问 <a href="https://links.jianshu.com/go?to=https://math.meta.stackexchange.com/questions/5020/mathjax-basic-tutorial-and-quick-reference">MathJax</a> 参考更多使用方法。</p><h3 id="3-6-分隔线"><a href="#3-6-分隔线" class="headerlink" title="3.6 分隔线"></a>3.6 分隔线</h3><p>你可以在一行中用<code>三个以上</code>的<code>星号、减号、底线</code>来建立一个分隔线，行内不能有其他东西。你也可以在<strong>星号或是减号中间插入空格</strong>。下面每种写法都可以建立分隔线：</p><p>代码：</p><pre><code class="markdown">* * *********- - ------------</code></pre><p>显示效果都一样：</p><hr><h3 id="3-7-HTML-原始码"><a href="#3-7-HTML-原始码" class="headerlink" title="3.7 HTML 原始码"></a>3.7 HTML 原始码</h3><p>在代码区块里面<code>， &amp; 、 &lt; 和 &gt; </code>会自动转成 HTML 实体，这样的方式让你非常容易使用 Markdown 插入范例用的 HTML 原始码，只需要复制贴上，剩下的 Markdown 都会帮你处理，例如：</p><p>代码：</p><pre><code class="html">第一个例子：&lt;div class=&quot;footer&quot;&gt;© 2004 Foo Corporation&lt;/div&gt;第二个例子：&lt;center&gt;&lt;table&gt;&lt;tr&gt;&lt;th rowspan=&quot;2&quot;&gt;值班人员&lt;/th&gt;&lt;th&gt;星期一&lt;/th&gt;&lt;th&gt;星期二&lt;/th&gt;&lt;th&gt;星期三&lt;/th&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;李强&lt;/td&gt;&lt;td&gt;张明&lt;/td&gt;&lt;td&gt;王平&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/center&gt;</code></pre><p>显示效果：</p><p>第一个例子：</p><div class="footer"> © 2004 Foo Corporation </div><p>第二个例子：</p><center><table><tr><th rowspan="2">值班人员</th><th>星期一</th><th>星期二</th><th>星期三</th></tr><tr><td>李强</td><td>张明</td><td>王平</td></tr></table></center><h3 id="3-8-特殊字"><a href="#3-8-特殊字" class="headerlink" title="3.8 特殊字"></a>3.8 特殊字</h3><p>特殊字符 描述 字符的代码 空格符  &lt; 小于号 &lt; &gt; 大于号 &gt; &amp; 和号 &amp; ￥ 人民币 ¥ © 版权 © ® 注册商标 ® °C 摄氏度 °C ± 正负号 ± × 乘号 × ÷ 除号 ÷ ² 平方（上标²） ² ³ 立方（上标³） ³</p><p>文章转载自简书<br>版权归属 ©2019 择势勤<br>作者：择势勤<br>链接：<a href="https://www.jianshu.com/p/ebe52d2d468f#fnref1">https://www.jianshu.com/p/ebe52d2d468f#fnref1</a></p><p>还有其他的，顺便也记一下</p><p>其他支持的 HTML 元素有：</p><pre><code class="markdown">&lt;kbd&gt;&lt;/kbd&gt;&lt;b&gt;&lt;/b&gt;&lt;i&gt;&lt;/i&gt; &lt;em&gt;&lt;/em&gt; &lt;sup&gt;&lt;/sup&gt;  &lt;sub&gt;&lt;/sub&gt;  &lt;br /&gt;etc.</code></pre><p>横向流程图源码格式：</p><pre><code class="markdown">graph LRA[方形] --&gt;B(圆角)    B --&gt; C&#123;条件a&#125;    C --&gt;|a=1| D[结果1]    C --&gt;|a=2| E[结果2]    F[横向流程图]</code></pre><p>竖向流程图源码格式：</p><pre><code class="markdown">graph TDA[方形] --&gt; B(圆角)    B --&gt; C&#123;条件a&#125;    C --&gt; |a=1| D[结果1]    C --&gt; |a=2| E[结果2]    F[竖向流程图]</code></pre><p>标准流程图源码格式：</p><pre><code class="markdown">st=&gt;start: 开始框op=&gt;operation: 处理框cond=&gt;condition: 判断框(是或否?)sub1=&gt;subroutine: 子流程io=&gt;inputoutput: 输入输出框e=&gt;end: 结束框st-&gt;op-&gt;condcond(yes)-&gt;io-&gt;econd(no)-&gt;sub1(right)-&gt;op</code></pre><p>标准流程图源码格式（横向）：</p><pre><code class="markdown">st=&gt;start: 开始框op=&gt;operation: 处理框cond=&gt;condition: 判断框(是或否?)sub1=&gt;subroutine: 子流程io=&gt;inputoutput: 输入输出框e=&gt;end: 结束框st(right)-&gt;op(right)-&gt;condcond(yes)-&gt;io(bottom)-&gt;econd(no)-&gt;sub1(right)-&gt;op</code></pre><p>UML时序图源码样例：</p><pre><code class="markdown">对象A-&gt;对象B: 对象B你好吗?（请求）Note right of 对象B: 对象B的描述Note left of 对象A: 对象A的描述(提示)对象B--&gt;对象A: 我很好(响应)对象A-&gt;对象B: 你真的好吗？</code></pre><p>UML时序图源码复杂样例：</p><pre><code class="markdown">Title: 标题：复杂使用对象A-&gt;对象B: 对象B你好吗?（请求）Note right of 对象B: 对象B的描述Note left of 对象A: 对象A的描述(提示)对象B--&gt;对象A: 我很好(响应)对象B-&gt;小三: 你好吗小三--&gt;&gt;对象A: 对象B找我了对象A-&gt;对象B: 你真的好吗？Note over 小三,对象B: 我们是朋友participant CNote right of C: 没人陪我玩</code></pre><p>UML标准时序图样例：</p><pre><code class="markdown">%% 时序图例子,-&gt; 直线，--&gt;虚线，-&gt;&gt;实线箭头  sequenceDiagram    participant 张三    participant 李四    张三-&gt;王五: 王五你好吗？    loop 健康检查        王五-&gt;王五: 与疾病战斗    end    Note right of 王五: 合理 食物 &lt;br/&gt;看医生...    李四--&gt;&gt;张三: 很好!    王五-&gt;李四: 你怎么样?    李四--&gt;王五: 很好!</code></pre><p>甘特图样例：</p><pre><code class="markdown">%% 语法示例        gantt        dateFormat  YYYY-MM-DD        title 软件开发甘特图        section 设计        需求                      :done,    des1, 2014-01-06,2014-01-08        原型                      :active,  des2, 2014-01-09, 3d        UI设计                     :         des3, after des2, 5d    未来任务                     :         des4, after des3, 5d        section 开发        学习准备理解需求                      :crit, done, 2014-01-06,24h        设计框架                             :crit, done, after des2, 2d        开发                                 :crit, active, 3d        未来任务                              :crit, 5d        耍                                   :2d        section 测试        功能测试                              :active, a1, after des3, 3d        压力测试                               :after a1  , 20h        测试报告                               : 48h</code></pre><hr><p>markdown可直接复制</p><p><a href="http://markdown.xiaoshujiang.com/">小书匠</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;参考：&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://wallleap.cn/2020/03/29/markdown/&quot;&gt;Markdown语法大全 | 个人学习心得体会 (wallleap.cn)&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://blog.csdn</summary>
      
    
    
    
    <category term="其它" scheme="https://vliamzh.github.io/categories/%E5%85%B6%E5%AE%83/"/>
    
    <category term="markdown" scheme="https://vliamzh.github.io/categories/%E5%85%B6%E5%AE%83/markdown/"/>
    
    
    <category term="markdown" scheme="https://vliamzh.github.io/tags/markdown/"/>
    
    <category term="语法" scheme="https://vliamzh.github.io/tags/%E8%AF%AD%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>备份</title>
    <link href="https://vliamzh.github.io/2024/05/13/%E5%A4%87%E4%BB%BD/"/>
    <id>https://vliamzh.github.io/2024/05/13/%E5%A4%87%E4%BB%BD/</id>
    <published>2024-05-13T13:43:10.000Z</published>
    <updated>2024-08-01T14:45:46.492Z</updated>
    
    <content type="html"><![CDATA[<h1 id="备份"><a href="#备份" class="headerlink" title="备份"></a>备份</h1><ol><li><p>需要在github创建一个仓库，然后clone该仓库</p><pre><code class="git">git clone https://github.com/vliamzh/blogbackup.git</code></pre></li><li><p>将之前博客目录全部复制到该文件夹下（除了.git&#x2F;），以后都在该目录下工作</p></li><li><p>需要备份的时候直接运行以下命令</p><pre><code class="git">git add . &amp;&amp; git commit -m &quot;update&quot; &amp;&amp; git push -f</code></pre></li></ol><p>2024&#x2F;08&#x2F;01更新：上述方式弃用，直接用下面的方法：</p><ol><li>博客根目录，执行 <code>git init</code> 创建 git 仓库。</li><li>在 github（或其他托管平台、自建远程仓库等） 创建仓库并和本地仓库建立联系。</li><li>在 <code>~/.bashrc</code> 文件中添加（windows可以用git bash操作）</li></ol><pre><code>alias hs=&#39;hexo clean &amp;&amp; hexo g &amp;&amp; hexo s&#39;alias hd=&#39;hexo clean &amp;&amp; hexo g &amp;&amp; hexo d &amp;&amp; git add . &amp;&amp; git commit -m &quot;update&quot; &amp;&amp; git push -f&#39;</code></pre>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;备份&quot;&gt;&lt;a href=&quot;#备份&quot; class=&quot;headerlink&quot; title=&quot;备份&quot;&gt;&lt;/a&gt;备份&lt;/h1&gt;&lt;ol&gt;
&lt;li&gt;&lt;p&gt;需要在github创建一个仓库，然后clone该仓库&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;git&quot;&gt;git clo</summary>
      
    
    
    
    <category term="其它" scheme="https://vliamzh.github.io/categories/%E5%85%B6%E5%AE%83/"/>
    
    <category term="hexo" scheme="https://vliamzh.github.io/categories/%E5%85%B6%E5%AE%83/hexo/"/>
    
    
    <category term="hexo" scheme="https://vliamzh.github.io/tags/hexo/"/>
    
    <category term="git" scheme="https://vliamzh.github.io/tags/git/"/>
    
    <category term="备份" scheme="https://vliamzh.github.io/tags/%E5%A4%87%E4%BB%BD/"/>
    
  </entry>
  
  <entry>
    <title>图床测试</title>
    <link href="https://vliamzh.github.io/2024/05/13/%E5%9B%BE%E7%89%87%E6%B5%8B%E8%AF%95/"/>
    <id>https://vliamzh.github.io/2024/05/13/%E5%9B%BE%E7%89%87%E6%B5%8B%E8%AF%95/</id>
    <published>2024-05-13T13:33:51.000Z</published>
    <updated>2024-05-13T13:43:32.116Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Picgo设置"><a href="#Picgo设置" class="headerlink" title="Picgo设置"></a>Picgo设置</h1><p><img src="https://cdn.jsdelivr.net/gh/vliamzh/image@main/image/202405132138605.png"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Picgo设置&quot;&gt;&lt;a href=&quot;#Picgo设置&quot; class=&quot;headerlink&quot; title=&quot;Picgo设置&quot;&gt;&lt;/a&gt;Picgo设置&lt;/h1&gt;&lt;p&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/vliamzh/imag</summary>
      
    
    
    
    <category term="其它" scheme="https://vliamzh.github.io/categories/%E5%85%B6%E5%AE%83/"/>
    
    <category term="图床" scheme="https://vliamzh.github.io/categories/%E5%85%B6%E5%AE%83/%E5%9B%BE%E5%BA%8A/"/>
    
    
    <category term="picgo" scheme="https://vliamzh.github.io/tags/picgo/"/>
    
    <category term="图床" scheme="https://vliamzh.github.io/tags/%E5%9B%BE%E5%BA%8A/"/>
    
    <category term="typora" scheme="https://vliamzh.github.io/tags/typora/"/>
    
  </entry>
  
  <entry>
    <title>hexo使用</title>
    <link href="https://vliamzh.github.io/2024/05/13/hexo%E4%BD%BF%E7%94%A8/"/>
    <id>https://vliamzh.github.io/2024/05/13/hexo%E4%BD%BF%E7%94%A8/</id>
    <published>2024-05-13T12:22:40.000Z</published>
    <updated>2024-08-01T14:23:31.898Z</updated>
    
    <content type="html"><![CDATA[<h1 id="设置置顶"><a href="#设置置顶" class="headerlink" title="设置置顶"></a>设置置顶</h1><hr><p>给需要置顶的文章加入top参数，如下：</p><pre><code class="xml">---title: 每天一个linux命令date: 2017-01-23 11:41:48top: 1categories:- 其它tags:- hexo---</code></pre><p>如果存在多个置顶文章，top后的参数越大，越靠前。</p><hr><h1 id="快捷命令"><a href="#快捷命令" class="headerlink" title="快捷命令"></a>快捷命令</h1><pre><code class="git">#创建一个新的文章$ hexo new &quot;文章名&quot;#生成静态文件$ hexo generate // hexo g#将一个草稿发布出去$ hexo publish [layout] &lt;filename&gt;#启动一个本地服务器$ hexo server // hexo s#推送到服务器hexo deploy // hexo d# 在git bash中设置快捷键echo &quot;alias hs=&#39;hexo clean &amp;&amp; hexo g &amp;&amp; hexo s&#39;  #启动本地服务alias hd=&#39;hexo clean &amp;&amp; hexo g &amp;&amp; hexo d&#39;  #部署博客&quot;&gt;&gt; ~/.bashrc &amp;&amp; source ~/.bashrc# 一般流程hexo cleanhexo ghexo s ，打开网页测试，没错误就可以输入下面的命令了hexo d</code></pre><hr><h1 id="备忘录"><a href="#备忘录" class="headerlink" title="备忘录"></a>备忘录</h1><pre><code class="git">#删除博客方法直接到博客主目录/source/_posts目录，找到你想删除的文章，鼠标右键删除即可，又或者重命名为其他文件（最好放到本地其他文件夹下）</code></pre>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;设置置顶&quot;&gt;&lt;a href=&quot;#设置置顶&quot; class=&quot;headerlink&quot; title=&quot;设置置顶&quot;&gt;&lt;/a&gt;设置置顶&lt;/h1&gt;&lt;hr&gt;
&lt;p&gt;给需要置顶的文章加入top参数，如下：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;xml&quot;&gt;---
title:</summary>
      
    
    
    
    <category term="其它" scheme="https://vliamzh.github.io/categories/%E5%85%B6%E5%AE%83/"/>
    
    <category term="hexo" scheme="https://vliamzh.github.io/categories/%E5%85%B6%E5%AE%83/hexo/"/>
    
    
    <category term="hexo" scheme="https://vliamzh.github.io/tags/hexo/"/>
    
  </entry>
  
</feed>
